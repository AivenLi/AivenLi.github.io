{"code":0,"msg":"success","data":[{"title":"下列叙述中错误的是（）。","chooseList":[{"title":"非线性结构中至少有一个根结点。","index":0,"selected":false},{"title":"有一个以上根结点的必定是非线性结构。","index":1,"selected":false},{"title":"有一个以上叶子结点的必定是非线性结构。","index":2,"selected":false},{"title":"非线性结构中可以没有根结点与叶子结点。","index":3,"selected":false}],"mode":0,"answer":0,"parse":"根据数据结构中各数据元素之间前后件关系的复杂程度，一般将数据结构分为两大类型：线性结构与非线性结构。一个非空的数据结构满足下列两个条件:①有且只有一个根结点；②每一个结点最多有一个前件，也最多有一个后件。则该数据结构为线性结构。如果一个数据结构不是线性结构，则称之为非线性结构，所以A选项错误。"},{"title":"设栈的顺序存储空间为 S(1:m)，初始状态为top\u003d０，则栈中的数据元素个数为（）。","chooseList":[{"title":"m-top","index":0,"selected":false},{"title":"m-top+1","index":1,"selected":false},{"title":"top","index":2,"selected":false},{"title":"top-m","index":3,"selected":false}],"mode":0,"answer":2,"parse":"由题目可知，该栈的数据由栈顶压向栈底，初始状态top \u003d 0 时，栈空，即栈中的元素个数为top。"},{"title":"已知如下定义：String s \u003d \"story\";下面（）表达式是合法的。","chooseList":[{"title":"s +\u003d books;","index":0,"selected":false},{"title":"char c \u003d s[1];","index":1,"selected":false},{"title":"int len \u003d s.length;","index":2,"selected":false},{"title":"String t \u003d s.toLowerCase();","index":3,"selected":false}],"mode":0,"answer":3,"parse":"选项A类型不一致，若此表达式改为s+\u003d\"books\"就对了；选项B中s[1]表示数组，Java中数组是对象，它需通过new关键字来创建；选项C中s的类型不确定，如果s定义的是数组的，则此表达式是合法的，因为数组中length是属性，而字符串中是通过length()方法获得字符长度的，故此表达式不合法。若把它改为int len\u003ds.length();就对了； 选项D中toLowerCase()是String类提供的一个方法，作用是将字符串中所有字符变为小写。返回一个字符串值赋给t。故本题答案为D。"},{"title":"设 x \u003d 1 , y \u003d 2 , z \u003d 3，则表达式 y+＝z--/++x 的值是（）。","chooseList":[{"title":"3","index":0,"selected":false},{"title":"3.5","index":1,"selected":false},{"title":"4","index":2,"selected":false},{"title":"5","index":3,"selected":false}],"mode":0,"answer":0,"parse":"++（--）运算符放变量前面表示先加（减）后用，放在变量后面表示先用后加（减），且优先级高于+、-、*、/等运算符。"},{"title":"outer: for (int i \u003d 0; i \u003c 3; ++i)\ninner: for (int j \u003d 0; j \u003c 2; ++j) {\nif (j \u003d\u003d 1 continue outer;\nSystem.out.println(j + \" and \" + i + \";\");\n}\n以上代码输出是（）。","chooseList":[{"title":"0 and 0;0 and 1;0 and 2;","index":0,"selected":false},{"title":"0 and 0;1 and 0;2 and 0;","index":1,"selected":false},{"title":"1 and 0;1 and 1;1 and 2;","index":2,"selected":false},{"title":"2 and 0;2 and 1;2 and 2;","index":3,"selected":false}],"mode":0,"answer":0,"parse":""},{"title":"计算机中的流是（）。","chooseList":[{"title":"流动的字节","index":0,"selected":false},{"title":"流动的对象","index":1,"selected":false},{"title":"流动的文件","index":2,"selected":false},{"title":"流动的数据缓冲区","index":3,"selected":false}],"mode":0,"answer":3,"parse":"流，最早从C语言中引入的。其可以看成是一个流动的数据缓冲区。数据从数据源方向经过缓冲区流向数据的目的地。在传送的过程中，其传送方式是串行的。在Java中的java.io包中定义了Java中常见流的接口与类。其中包括两个最基本的流的抽象类，它们分别是OutputStream与InputStream。其余的流都分别从这两个基本类中继承而来。"},{"title":"Swing构件的程序不具有（）。","chooseList":[{"title":"本地代码","index":0,"selected":false},{"title":"标签","index":1,"selected":false},{"title":"菜单","index":2,"selected":false},{"title":"容器","index":3,"selected":false}],"mode":0,"answer":0,"parse":"随着发展的需要，Swing出现了，Swing组件几乎都是轻量组件，与重量组件相比，没有本地的对等组件，不像重量组件要在它们自己的本地不透明窗体中绘制，轻量组件在它们的重量组件的窗口中绘制。Swing是由100%纯Java实现的，Swing组件是用Java实现的轻量级（ light-weight）组件，没有本地代码，不依赖操作系统的支持，这是它与AWT组件的最大区别。"},{"title":"当一个包含Applet的Web页面被其他页面覆盖时，被调用的Applet方法是()。","chooseList":[{"title":"start()","index":0,"selected":false},{"title":"init()","index":1,"selected":false},{"title":"stop()","index":2,"selected":false},{"title":"destroy()","index":3,"selected":false}],"mode":0,"answer":2,"parse":""},{"title":"下列叙述中正确的是（）。","chooseList":[{"title":"线性结构可以为空","index":0,"selected":false},{"title":"只有一个根结点和一个叶子结点的必定是线性结构。","index":1,"selected":false},{"title":"只有一个根结点的必定是线性结构或二叉树。","index":2,"selected":false},{"title":"没有根结点的一定是非线性结构。","index":3,"selected":false}],"mode":0,"answer":0,"parse":"线性结构与非线性结构都可以是空的数据结构，一个空的数据结构究竟是属于线性结构还是属于非线性结构，这要根据具体情况来确定，所以D选项错误；二叉树是非线性结构中的一种常见结构。二叉树有两个特点：①非空二叉树只有一个根结点，所以C选项错误；②每一个结点最多有两颗子树，且分别称为该结点的左子树与右子树，只有一个根结点和一个叶子结点可以构成一个二叉树，因此它可能是非线性结构，所以B选项错误。"},{"title":"在具有n个结点的二叉树中，如果各结点值互不相同，但前序遍历序列与中序遍历序列相同，则该二叉树的深度为（根结点在第1层）（）。","chooseList":[{"title":"n","index":0,"selected":false},{"title":"n/2+1","index":1,"selected":false},{"title":"n+1","index":2,"selected":false},{"title":"n-1","index":3,"selected":false}],"mode":0,"answer":0,"parse":"二叉树的前序遍历步骤为首先访问根结点，然后前序遍历左子树，最后前序遍历右子树。中序遍历步骤为首先中序遍历左子树，然后访问根结点，最后中序遍历右子树。若前序遍历和中序遍历相同，则说明此二叉树每个结点均缺失了左结点，故二叉树每一层均有一个结点存在，所以深度为n。"},{"title":"以下（）字符串是Java中合法的标识符。","chooseList":[{"title":"super","index":0,"selected":false},{"title":"3number","index":1,"selected":false},{"title":"#number","index":2,"selected":false},{"title":"$number","index":3,"selected":false}],"mode":0,"answer":3,"parse":"Java标识符命名规则如下：\n1. 标识符是以字母、下划线、美元符（$）作为首字符的字符串序列。在首字符后面可以跟字母、下划线、美元符和数字。\n2. 标识符区分大小写。\n3. 标识符的字符数目没有限制，但为便于阅读和记忆，不宜太长。\n4. 关键字不能作为用户标识符，例如本题的“super”。"},{"title":"以下代码段执行后的输出结果为（）。\nint x \u003d 3;\nint y \u003d 10;\nSystem.out.println(y % x);","chooseList":[{"title":"1.0","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"3","index":2,"selected":false},{"title":"3.0","index":3,"selected":false}],"mode":0,"answer":1,"parse":""},{"title":"下列m的哪个值将引起“defaule”的输出（）。[image]","chooseList":[{"title":"0","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"2","index":2,"selected":false},{"title":"3","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/java/img/java_test4_23.png","parse":"m为0，引起“case 0、case 1、case 2”的输出，因为“case 2”中有“break”，所以不会向下执行；m为1将会引起“case 1、case 2”的输出；m为2将会引起“case 2”的输出；m为3，不满足“case”部分，所以将会引起“default”的输出。"},{"title":"当方法遇到异常又不知如何处理时，下列（）做法是正确的。","chooseList":[{"title":"捕获异常","index":0,"selected":false},{"title":"抛出异常","index":1,"selected":false},{"title":"声明异常","index":2,"selected":false},{"title":"嵌套异常","index":3,"selected":false}],"mode":0,"answer":2,"parse":"在Java语言中，有时一个方法生成一个异常，但该方法并不能确定如何处理此异常，如找不到文件之类的异常，必须将异常传递给调用方法，由调用它的方法来处理，这种时候方法用声明异常抛出，让异常对象可从调用栈向后传递，直至有相应的方法捕获它为止。所以当方法遇到异常又不知如何处理时，应声明异常。"},{"title":"要串行化某些类的对象，这些类就必须实现（）。","chooseList":[{"title":"Serializable接口","index":0,"selected":false},{"title":"java.io.Externalizable接口","index":1,"selected":false},{"title":"java.io.DataInput接口","index":2,"selected":false},{"title":"DataOutput接口","index":3,"selected":false}],"mode":0,"answer":0,"parse":"对Java对象的读、写的过程被称为对象串行化。任何一个对象只有它所对应的类实现了Serializable接口时，才是可串行化的。因此如果要串行化某些类的对象，这些类就必须实现Serializable接口。"},{"title":"下列代码的下划线处应填入的是（）。[image]","chooseList":[{"title":"BufferedReader","index":0,"selected":false},{"title":"InputStreamReader","index":1,"selected":false},{"title":"InputStream","index":2,"selected":false},{"title":"OutputStream","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/java/img/java_test4_38.png","parse":"InputStreamReader和BufferedReader都是字符类输入流，都是抽象类Reader的子类。本程序的作用是读取用户输入的一行字符，再输出，由于程序中同时用到InputStreamReader和BufferedReader类的对象，所以输入的字符将被输出两次。根据语句\"InputStreamReader ir;\"和语句\"in\u003dnew BufferedReader(ir);\"可知，下划线处填\"InputStreamReader\"。"},{"title":"下列叙述中正确的是（）。","chooseList":[{"title":"算法复杂度是指算法控制结构的复杂程度。","index":0,"selected":false},{"title":"算法设计只需考虑结果的可靠性。","index":1,"selected":false},{"title":"数据的存储结构会影响算法的效率。","index":2,"selected":false},{"title":"算法复杂度是用算法中指令的条数来度量的。","index":3,"selected":false}],"mode":0,"answer":2,"parse":"算法的设计要求包括效率与低存储量，即要考虑算法的时间复杂度与空间复杂度。因此选项B错误；算法的复杂度主要包括时间复杂度和空间复杂度。所谓算法的时间复杂度，是指执行算法所需要的计算工作量；一个算法的空间复杂度，一般是指执行这个算法所需要的内存空间，因此选项A、D错误。"},{"title":"下列叙述中错误的是（）。","chooseList":[{"title":"二分查找法只适用于顺序存储的线性有序表","index":0,"selected":false},{"title":"所有二叉树都只能用二叉链表表示","index":1,"selected":false},{"title":"有多个指针域的链表也有可能是线性结构","index":2,"selected":false},{"title":"循环队列是队列的存储结构","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在计算机中，二叉树通常采用链式存储结构。与线性链表类似，用于存储二叉树中各元素的存储结点也分为数据域和指针域。由于二叉树的存储结构中每一个存储结点由两个指针域，因此，满二叉树和完全二叉树的链式存储结构也称为二叉链表。二叉树最多有两颗子树，如子树缺失的二叉树则不是二叉链表表示的，所以选项B错误。"},{"title":"编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为（）。","chooseList":[{"title":".java","index":0,"selected":false},{"title":".class","index":1,"selected":false},{"title":".html","index":2,"selected":false},{"title":".exe","index":3,"selected":false}],"mode":0,"answer":1,"parse":"1. Java的源程序代码的扩展名为.java。\n2. Java的编译器和解释器的扩展名为.exe，他们分别是javac.exe，java.exe。\n3. 通过Java编译器编译生成的是二进制字节码文件，其扩展名为.class。\n4. 调用applet小程序的HTML文件的扩展名为.html或.htm。"},{"title":"已知如下代码：\nboolean m \u003d true;\nif (m \u003d\u003d false) {\nSystem.out.println(\"False\");\n} else {\nSystem.out.println(\"True\");\n}\n执行结果是（）。","chooseList":[{"title":"False","index":0,"selected":false},{"title":"True","index":1,"selected":false},{"title":"None","index":2,"selected":false},{"title":"运行是出错","index":3,"selected":false}],"mode":0,"answer":1,"parse":"代码中m为true，不满足if条件继而执行else下的语句，故输出“True”。"},{"title":"关于被私有访问控制符private修饰的成员变量，以下说法正确的是（）。","chooseList":[{"title":"只能被同一个包中的类访问","index":0,"selected":false},{"title":"只能被该类自身所访问和修改","index":1,"selected":false},{"title":"可以被两种类访问和引用：该类本身、该类的所有子类","index":2,"selected":false},{"title":"可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类","index":3,"selected":false}],"mode":0,"answer":1,"parse":"private修饰的变量说明变量为私有访问。只能被该类自己访问或调用，是对成员变量的高级保护。故本题答案为B。"},{"title":"下面（）方法与applet的显示无关？","chooseList":[{"title":"update()","index":0,"selected":false},{"title":"draw()","index":1,"selected":false},{"title":"repaint()","index":2,"selected":false},{"title":"paint()","index":3,"selected":false}],"mode":0,"answer":1,"parse":""},{"title":"如果希望所有的控件在界面上呈网格状布局，应使用下列（）布局管理器。","chooseList":[{"title":"CardLayout","index":0,"selected":false},{"title":"GridLayout","index":1,"selected":false},{"title":"BorderLayout","index":2,"selected":false},{"title":"FlowLayout","index":3,"selected":false}],"mode":0,"answer":1,"parse":"1、CardLayout布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个构件，当然每层都可以利用Panel来实现复杂的用户界面。\n2、GridLayout布局管理器使容器中各个构件呈网格状布局，平均占据容器的空间。即使容器的大小发生变化，每个构件还是平均占据容器的空间。构件在往容器中放置的时候，是按照从上到下、从左到右的规律进行的。\n3、BorderLayout布局管理器把容器分成5个区域：North,South,East,West和Center，每个区域只能放置一个构件。\n4、FlowLayout：构件在容器中的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个构件先添加到容器中第一行的最左边，后续的构件依次添加到上一个构件的右边，如果当前行已放置不下该构件，则放置到下一行的最左边。\n故本题答案为B。"},{"title":"下列实现了动态数组的是（）。","chooseList":[{"title":"Vector和ArrayList","index":0,"selected":false},{"title":"Map和Set","index":1,"selected":false},{"title":"Vector和Map","index":2,"selected":false},{"title":"ArrayList和Set","index":3,"selected":false}],"mode":0,"answer":0,"parse":"Java动态数组是一种可以任意伸缩数组长度的对象，在Java中比较常用的是ArrayList，Vector等。\njava.util.Vector提供了向量(Vector)类以实现类似动态数组的功能。\njava.util.ArrayList（数组列表）在运行时能动态自动调整数组的大小。ArrayList类在定义数组时，不必限定数组的大小。在数组列表初始化时，可用add()方法将数组元素赋值。故本题答案为A。"},{"title":"某二叉树的中序遍历序列为CBADE，后序遍历序列为CBEDA，则前序遍历序列为（）。","chooseList":[{"title":"CBEDA","index":0,"selected":false},{"title":"ABCDE","index":1,"selected":false},{"title":"CBADE","index":2,"selected":false},{"title":"EDCBA","index":3,"selected":false}],"mode":0,"answer":1,"parse":"前序遍历的规则是：根结点→左子树→右子树，中序遍历是：左子树→根结点→右子树，后序遍历是：左子树→右子树→根结点。由后序遍历序列可知根结点是A，那么前序遍历一定是A结点开头，所以A选项正确。所以本题答案为B。 "},{"title":"设栈的顺序存储空间为 S(1:m)，初始状态为top\u003dm+1，则栈中的数据元素个数为（）。","chooseList":[{"title":"m-top+1","index":0,"selected":false},{"title":"top-m+1","index":1,"selected":false},{"title":"m-top","index":2,"selected":false},{"title":"top-m","index":3,"selected":false}],"mode":0,"answer":0,"parse":"栈是限定在一端进行插入与删除的线性表。在栈的顺序存储空间S(1:m)中，S(bottom)通常为栈底元素（在栈非空的情况下），S(top)为栈顶元素。,Top\u003d0表示栈空；top\u003dm表示栈满。入栈运算时指在栈顶位置插入一个新元素（即top加1）退栈运算是指取出栈顶元素赋给一个指定的变量（即top减1），因此栈内元组个数为m-top+1。"},{"title":"以下（）不是Java中有效的关键字。","chooseList":[{"title":"const","index":0,"selected":false},{"title":"NULL","index":1,"selected":false},{"title":"false","index":2,"selected":false},{"title":"this","index":3,"selected":false}],"mode":0,"answer":1,"parse":"Java中常量null，false，true，new，this，const，break都是小写。"},{"title":"在Java中，以下（）约束符是不正确的。","chooseList":[{"title":"private","index":0,"selected":false},{"title":"public","index":1,"selected":false},{"title":"protected","index":2,"selected":false},{"title":"friend","index":3,"selected":false}],"mode":0,"answer":3,"parse":"Java的修饰符包括public，private，protected，friendly，final等。"},{"title":"下面的代码段中，执行之后i和j的值是（）。\nint i \u003d 1;\nint j;\nj \u003d i++;","chooseList":[{"title":"1, 1","index":0,"selected":false},{"title":"1, 2","index":1,"selected":false},{"title":"2, 1","index":2,"selected":false},{"title":"2, 2","index":3,"selected":false}],"mode":0,"answer":2,"parse":"后缀自增表示先用后加，所以j\u003d1，i\u003d2。"},{"title":"下列（）内容是异常的含义。","chooseList":[{"title":"程序的语法错","index":0,"selected":false},{"title":"程序编译或运行中所发生的异常事件","index":1,"selected":false},{"title":"程序预定义好的异常事件","index":2,"selected":false},{"title":"程序编译错误","index":3,"selected":false}],"mode":0,"answer":1,"parse":"对程序语言而言，编写程序时出现错误是不可避免的，一般有编译错和运行错两类。Java语言认为那些可预料和不可预料的编译和运行时的出错称为异常。在Java语言中，把异常也作为一种对象，它在程序运行出错时被创建，异常控制是Java语言处理程序出错的有效机制。"},{"title":"一个Java Application运行后，在系统中是作为一个（）。","chooseList":[{"title":"线程","index":0,"selected":false},{"title":"进程","index":1,"selected":false},{"title":"进程或线程","index":2,"selected":false},{"title":"不可预知","index":3,"selected":false}],"mode":0,"answer":1,"parse":"一个Java Application运行后在系统中作为一个独立的进程参与系统调度，但在该进程中可以通过创建Thread类的实例的方法来创建多个线程。在一个进程中的各个线程之间拥有共同的上下文环境。"},{"title":"运行下列程序时，若没有test.dat文件，则（）。[image]","chooseList":[{"title":"输出exception","index":0,"selected":false},{"title":"输出test.dat","index":1,"selected":false},{"title":"输出IOException","index":2,"selected":false},{"title":"无显示","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/java/img/java_test4_37.png","parse":"在Java中提供了结构化的异常处理功能，其主要是通过try...catch语句来实现的。在Java中可以将可能产生异常的代码放入到try子句中，如果产生异常，将会执行catch子句。在本程序执行过程中，由于找不到\"test.dat\"，产生异常，转而执行catch子句，通过语句\"System.out.println(\"exception\");\"，输出：exception。"},{"title":"设栈的存储空间为 S(1:50)，初始状态为 top\u003d-1。现经过一系列正常的入栈与退栈操作后，top\u003d30，则栈中的元素个数为（）。","chooseList":[{"title":"19","index":0,"selected":false},{"title":"31","index":1,"selected":false},{"title":"20","index":2,"selected":false},{"title":"30","index":3,"selected":false}],"mode":0,"answer":3,"parse":"栈是限定在一端进行插入与删除的线性表。在栈的顺序存储空间S(1:m)中，S(bottom)通常为栈底元素（在栈非空的情况下），S(top)为栈顶元素。Top\u003d0表示栈空，top\u003dm表示栈满。入栈运算时指在栈顶位置插入一个新元素（既top加1）退栈运算是指取出栈顶元素赋给一个指定的变量（即top减1），所以当top\u003d30时，栈中元素也为30。"},{"title":"下列叙述中错误的是（）。","chooseList":[{"title":"不管是顺序栈还是带链的栈，在操作过程中其栈底指针均是固定不变的。","index":0,"selected":false},{"title":"带链栈的栈底指针在操作过程中是有可能改变的。","index":1,"selected":false},{"title":"不管是顺序栈还是带链的栈，在操作过程中其栈顶指针均是动态变化的。","index":2,"selected":false},{"title":"顺序栈的栈底指针在操作过程中是固定不变的。","index":3,"selected":false}],"mode":0,"answer":0,"parse":"栈是一种特殊的线性表，是按照\"先进后出，后进先出\"的原则组织数据的。链式结构则把每一个存储结点分两部分：一部分用于存储数据元素的值，称为数据域；另一部分用于存放下一个元素的序号，称指针域。带链的栈则可以通过指针域的变化改变原有的栈的组织数据原则；而顺序栈的栈底指针不变，栈顶指针改变，所以选项A错误。"},{"title":"下面（）是main()函数的合法参数。","chooseList":[{"title":"char args[]","index":0,"selected":false},{"title":"char args[][]","index":1,"selected":false},{"title":"String args[]","index":2,"selected":false},{"title":"String args","index":3,"selected":false}],"mode":0,"answer":2,"parse":"main()方法是一个特殊的方法，它是所有的Java Application程序执行的入口点，所以任何一个Java Application方法必须有且只能有一个main()方法，而且这个main()方法的格式统一为：\npublic static void main(String args[])"},{"title":"为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为（）。","chooseList":[{"title":"static void method()","index":0,"selected":false},{"title":"public void method()","index":1,"selected":false},{"title":"final void method()","index":2,"selected":false},{"title":"abstract void method()","index":3,"selected":false}],"mode":0,"answer":0,"parse":"1. public修饰的方法可被其他类访问或引用；\n2. abstract修饰的方法是抽象方法，抽象方法没有方法体，要使用抽象方法必须先实现该抽象方法；\n3. final修饰的方法不能被继承；\n4. static修饰的方法称为静态方法，静态方法不需要类的实例化就可以被类直接调用。"},{"title":"监听器接口的方法返回值的类型是（）。","chooseList":[{"title":"int","index":0,"selected":false},{"title":"String","index":1,"selected":false},{"title":"void","index":2,"selected":false},{"title":"Object","index":3,"selected":false}],"mode":0,"answer":2,"parse":"每个事件都有自己的监听器，监听器本身是一种接口，该接口中的方法，返回值是void类型。当要为指定的类注册监听器时，就可以通过定在实现该接口的类中定义该方法，这样可以在某个事件发生后，将会自动执行相应方法中的代码。"},{"title":"当检索一个压缩文件时，首先要建立压缩文件输入流对象。该对象（）。","chooseList":[{"title":"以选中的压缩文件为参数","index":0,"selected":false},{"title":"以FileInputStream对象为参数","index":1,"selected":false},{"title":"以InputStreamReader对象为参数","index":2,"selected":false},{"title":"以BufferedReader对象为参数","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在java.io包中提供了对压缩文件进行操作的能力。它是通过压缩文件输入流与压缩文件输出流来实现的，其分别继承自InflaterInputStream与DeflaterOutputStream。在创建压缩文件输入流时，其初始化参数是一个FileInputStream类的实例。"},{"title":"语句\"Hello\".equals(\"hello\");的正确执行结果是（）。","chooseList":[{"title":"true","index":0,"selected":false},{"title":"false","index":1,"selected":false},{"title":"0","index":2,"selected":false},{"title":"1","index":3,"selected":false}],"mode":0,"answer":1,"parse":"equals()是Object的方法，和\"\u003d\u003d\"一样，功能是比较两个操作数是否是同一个对象，但类库中许多子类重写了equals()方法，使其变为比较两个操作数的内容是否一样，两串相等则返回ture，否则返回false。"},{"title":"如果要从一个HTML文件中提取名为message的参数的值，需要在Applet类的init()方法中使用的代码行是()。","chooseList":[{"title":"String s \u003d getParameter(\"message\")","index":0,"selected":false},{"title":"String s \u003d getParameter(\"MESSAGE\")","index":1,"selected":false},{"title":"String s \u003d Parameter(\"message\")","index":2,"selected":false},{"title":"String s \u003d getParameter(\"message\")或String s \u003d getParameter(\"MESSAGE\")","index":3,"selected":false}],"mode":0,"answer":0,"parse":"Applet被下载时，在Applet的init()方法中使用getParameter()方法获取参数。getParameter()方法的入口参数是所取参数的名字（必须与\u003cparam\u003e标记中的name指示的名字相同），返回值是参数的值。另外，JAVA是严格区分大小写的，所以参数\"MESSAGE\"和参数\"message\"不同。"}]}