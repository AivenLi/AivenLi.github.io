{"code":0,"msg":"success","data":[{"title":"以下叙述中正确的是（ ）。","chooseList":[{"title":"C语言程序需要包含MAIN函数","index":0,"selected":false},{"title":"程序要包含全部基本结构才是结构化程序","index":1,"selected":false},{"title":"不运行程序是不能发现程序中的语法错误的","index":2,"selected":false},{"title":"任何复杂问题都可以使用只包含三种基本结构的算法来解决","index":3,"selected":false}],"mode":0,"answer":3,"parse":"C语言程序必须要有main函数，而不是MAIN函数，A错误；由三种基本结构所构成的程序称为结构化程序，而不需要全部包含，不能包含其他结构程序，B错误；C语言程序在运行前需要编译、链接等步骤，编译时可以发现代码中的语法错误，C错误；由三种基本结构组成的算法可以解决任何复杂的问题，D正确。"},{"title":"下面不属于软件需求分析阶段任务的是（ ）。","chooseList":[{"title":"需求配置","index":0,"selected":false},{"title":"需求获取","index":1,"selected":false},{"title":"需求分析","index":2,"selected":false},{"title":"需求评审","index":3,"selected":false}],"mode":0,"answer":0,"parse":"需求分析阶段的工作可以分为4个方面：需求获取、需求分析、需求规格说明书和需求评审。故选A"},{"title":"下面说法正确的是（ ）。","chooseList":[{"title":"文件指针的值是文件的长度（以字节为单位）","index":0,"selected":false},{"title":"文件指针的值是文件名字符串存放的首地址","index":1,"selected":false},{"title":"文件指针是指针类型的变量","index":2,"selected":false},{"title":"fscanf函数可以指向任意指定文件中写入任意指定字符","index":3,"selected":false}],"mode":0,"answer":2,"parse":"文件指针实际上是指向一个结构体类型的指针，这个结构体中包含有诸如：缓冲区的地址、在缓冲区中当前存取的字符的位置、对文件时“读”还是“写”、是否出错、是否已经遇到文件结束符标志等信息，选项C正确"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nchar x,a\u003d\u0027A\u0027,b\u003d\u0027B\u0027,c\u003d\u0027C\u0027,d\u003d\u0027D\u0027;\nx\u003d(a\u003cb)?a:b;\nx\u003d(x\u003ec)?c:x;\nx\u003d(d\u003ex)?x:d;\nprintf(\"%c\\n\",x);\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"D","index":0,"selected":false},{"title":"B","index":1,"selected":false},{"title":"C","index":2,"selected":false},{"title":"A","index":3,"selected":false}],"mode":0,"answer":3,"parse":"三目运算符：“表达式1 ? 表达式2 : 表达式3”，如果表达式1的值为1，则取表达式2，否则取表达式3，在C语言中，A\u003cB\u003cC\u003cD，所以执行x\u003d(a\u003cb)?a:b之后x\u003d\u0027A\u0027，同理可得最后x\u003dA"},{"title":"以下有关全局变量的叙述中错误的是（ ）。","chooseList":[{"title":"全局变量没被引用时，不占用内存","index":0,"selected":false},{"title":"所有在函数体外定义的变量都是全局变量","index":1,"selected":false},{"title":"全局变量可以和局部变量同名","index":2,"selected":false},{"title":"全局变量的生命周期一直持续到程序结束","index":3,"selected":false}],"mode":0,"answer":0,"parse":"全局变量在程序运行时就分配了存储空间，直到程序结束，A错误，选A"},{"title":"设某棵树的度为3，其中度为3,2,1的结点个数分别为3,0,4。则该树中的叶子结点数为（ ）。","chooseList":[{"title":"6","index":0,"selected":false},{"title":"7","index":1,"selected":false},{"title":"8","index":2,"selected":false},{"title":"不可能有这样的树","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在树结构中，一个结点所拥有的后继个数称为该结点的度，所有结点中最大的度称为树的度。由题目可以知道，若三种度的结点分开成子树，共包含结点3*3+2*0+1*4\u003d13个，再加一个根结点即为14。则该树中叶子结点个数为14-3-0-4\u003d7。"},{"title":"若有定义\ntypedef int *(*T)[10];\nT a;\n则以下与上述中的a的类型完全相同的是（ ）。","chooseList":[{"title":"int *(*a)[10];","index":0,"selected":false},{"title":"int **a[10];","index":1,"selected":false},{"title":"int *(a)[10];","index":2,"selected":false},{"title":"int *(*a[10]);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"typedef int *(*T)[10]，T指针数组指针类型，A选项定义的a也是指针数组指针，故选A；\nB选项定义的a是二级指针数组；C选项的是指针数组；D选项和B选项一样。"},{"title":"设栈的存储空间为S(1:50)，初始状态为top\u003d51。现经过一系列正常的入栈与出栈操作后，top\u003d50，则栈中的元素个数为（ ）。","chooseList":[{"title":"0","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"49","index":2,"selected":false},{"title":"50","index":3,"selected":false}],"mode":0,"answer":1,"parse":"栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈即在栈顶位置插入一个新元素，出栈则取出栈顶元素。栈为空时，栈顶指针top\u003d0，经过入栈和出栈运算，指针时钟指向栈顶元素。初始状态为top\u003d51，当top\u003d50时，则栈中S(50:51)存储着元素51-50\u003d1个元素。故选B"},{"title":"度为3的一棵树共有30个结点，其中度为3,1的结点个数分别为3,4。则该树中的叶子结点个数为（ ）。","chooseList":[{"title":"14","index":0,"selected":false},{"title":"15","index":1,"selected":false},{"title":"16","index":2,"selected":false},{"title":"不可能有这样的树","index":3,"selected":false}],"mode":0,"answer":1,"parse":"同上"},{"title":"R(C#,Cn,T,Ta)（其中C#为课程号，Cn为课程名，T为教师名，Ta为教师地址）\n并且假定不同课程号可以有相同的课程名，每门课程只有一位任课教师，但每位教师可以有多门课程。关系R范式最高达到（ ）。","chooseList":[{"title":"1NF","index":0,"selected":false},{"title":"2NF","index":1,"selected":false},{"title":"3NF","index":2,"selected":false},{"title":"BCNF","index":3,"selected":false}],"mode":0,"answer":1,"parse":"题目中关系模式R(C#,Cn,T,Ta)（其中C#为课程号，Cn为课程名，T为教师名，Ta为教师地址）是个简单的表，即关系数据库，因此符合第一范式。而此关系中课程名可以相同、教师名可以重复、教师地址因为教师名可以重复也可以重复，因此他们都完全依赖于主键课程号，因此符合第二范式。在此关系中教师地址可依赖于教师名，因此它不符合第三范式。故选B"},{"title":"以下叙述中正确的是（ ）。","chooseList":[{"title":"C语言编译系统对标识符的长度没有规定","index":0,"selected":false},{"title":"C语言标识符的规定长度因系统而异","index":1,"selected":false},{"title":"C语言标规定标识符长度最多允许16个字符，超长报错","index":2,"selected":false},{"title":"C语言规定以下划线开头的标识符长度必须大于1","index":3,"selected":false}],"mode":0,"answer":1,"parse":"对于标识符长度，C语言编译系统是有规定的，即标识符的前若干个字符有效，超过的字符将不被识别，不同的C语言编译系统所规定的标识符有效长度是不同的，故选B"},{"title":"在希尔排序法中，每经过一次数据交换后（ ）。","chooseList":[{"title":"只能消除一个逆序","index":0,"selected":false},{"title":"能消除多个逆序","index":1,"selected":false},{"title":"不会产生新的逆序","index":2,"selected":false},{"title":"消除的逆序个数一定比新产生的逆序个数多","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在希尔排序过程中，虽然对于每一个子表采用的仍是插入排序，但是在子表中每进行一次比较就有可能移去整个线性表中的多个逆序，从而改善了整个排序过程的性能。B正确"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nint a[3][3]\u003d{0,1,2,3,4,5,6,7,8},(*p)[3],i;\np\u003da;\nfor(i\u003d0;i\u003c3;i++) {\nprintf(\"%d \",(*p)[i]);p++;\n}\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"0 3 6","index":0,"selected":false},{"title":"0 1 2","index":1,"selected":false},{"title":"0 4 8","index":2,"selected":false},{"title":"1 4 7","index":3,"selected":false}],"mode":0,"answer":2,"parse":"(*p)[3]叫数组指针，p是一个指针，指向大小为3的数组，p++跨越的数组单位个数是3个，所以每次循环之后p都会向后移动三个元素（三次循环分别指向0 3 6），而输出语句是(*p)[i]，所以每次输出的数都是距离当前p指向的位置再往后i个单位的数。所以输出结果为0 4 8，选C"},{"title":"以下程序拟实现计算s\u003d1+2*2+3*3+...+n*n+...，直到s\u003e1000为止\n#include\u003cstdio.h\u003e\nint main() {\nint s,n;\ns\u003d1;\nn\u003d1;\ndo {\nn\u003dn+1;s\u003ds+n*n;\n} while(s\u003e1000);\nprintf(\"s\u003d%d\\n\",s);\nreturn 0;\n}\n该程序不能得到正确结果，以下对程序修改正确的是（ ）。","chooseList":[{"title":"把n\u003d1改为n\u003d0","index":0,"selected":false},{"title":"把s\u003d1改为s\u003d0","index":1,"selected":false},{"title":"把while(s\u003e1000)改为while(s\u003c\u003d1000)","index":2,"selected":false},{"title":"把n\u003dn+1改为n\u003dn*n","index":3,"selected":false}],"mode":0,"answer":2,"parse":"根据题意得出循环的条件是s\u003c\u003d1000，所以选C"},{"title":"以下叙述中正确的是（ ）。","chooseList":[{"title":"文件指针是一种特殊的指针类型变量","index":0,"selected":false},{"title":"文件指针的值等于文件当前读写位置，以字节为单位","index":1,"selected":false},{"title":"文件指针的值等于文件在计算机硬盘中的存储位置","index":2,"selected":false},{"title":"调用fscanf函数只能向文本文件中写入任意字符","index":3,"selected":false}],"mode":0,"answer":0,"parse":"文件指针实际上是指向一个结构体类型的指针，这个结构体中包含有诸如：缓冲区的地址、在缓冲区中当前存取的字符的位置、对文件是“读”还是“写”、是否出错、是否已经遇到文件结束标志灯信息，选项A正确，B、C错误；fscanf函数只能从文本文件中输入数据到内存，选项D错误。"},{"title":"若有定义\nfloat a\u003d12.3f;double b\u003d456.78;\n若想用printf函数输出a和b的值，关于输出格式，以下说法正确的是（ ）。","chooseList":[{"title":"只能用%lf输出a，用%f输出b","index":0,"selected":false},{"title":"只能用%f输出啊，用%lf输出b","index":1,"selected":false},{"title":"只能用%lf输出a和b","index":2,"selected":false},{"title":"既可以用%f输出a，也可以输出b","index":3,"selected":false}],"mode":0,"answer":3,"parse":"C语言中，%f是格式字符，表示以带小数点的数字形式输出浮点数，它既可以输出单精度数也可以输出双精度数，所以本题答案为D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nvoid sub(double, double*);\nint main() {\ndouble x,y;\nscanf(\"%lf%lf\",\u0026x,\u0026y);\nsub(x,\u0026y);\nprintf(\"x\u003d%f y\u003d%f\\n\",x,y);\nreturn 0;\n}\nvoid sub(double a, double *pb) {\na\u003da-*pb;\n*pb\u003d*pb-a;\n}\n程序运行时输入：\n10.2 3.5\u003cCR\u003e\n则输出结果为（ ）。","chooseList":[{"title":"x\u003d10.200000 y\u003d3.200000","index":0,"selected":false},{"title":"x\u003d6.700000 y\u003d13.700000","index":1,"selected":false},{"title":"x\u003d7.000000 y\u003d3.500000","index":2,"selected":false},{"title":"x\u003d13.400000 y\u003d-7.000000","index":3,"selected":false}],"mode":0,"answer":0,"parse":"参数传递是按值传递，所以形参不会改变实参的值，当形参是指针时，因为传递的值是一个地址，形参可以通过地址修改值，此时实参的值也会被改变，所以选A。"},{"title":"有下列程序\n#include\u003cstdio.h\u003e\n#include\u003cstring.h\u003e\ntypedef struct stu {\nchar name[9];\nchar gender;\nint score;\nstruct stu *next;\n} STU;\nvoid f(STU *a) {\nSTU c\u003d{\"Sun\",\u0027f\u0027,90};\nSTU d\u003d{\"Li\",\u0027m\u0027,100};\nstrcpy(a-\u003ename,c.name);\na-\u003egender\u003dc.gender;\na-\u003escore\u003dc.score;\n*a-\u003enext\u003dd;\n}\nint main() {\nSTU a\u003d{\"Zhao\", \u0027m\u0027,85};\nb\u003d{\"Qian\",\u0027f\u0027,95};\na.next\u003d\u0026b;\nf(\u0026a);\nprintf(\"%s,%c,%d,%s,%c,%d\",\na.name,a.gender,a.score,a.next-\u003ename,\na.next-\u003egender,a.next-\u003esocre);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"Sun,f,90,Qian,f,95","index":0,"selected":false},{"title":"Zhao,m,85,Qian,f,95","index":1,"selected":false},{"title":"Zhao,m,85,Li,m,100","index":2,"selected":false},{"title":"Sun,f,90,Li,m,100","index":3,"selected":false}],"mode":0,"answer":3,"parse":"函数f把c的下一个结点替换成了d，排除A、B选项，同时把a结点的数据赋给了c结点，所以答案是D"},{"title":"将数据库的结果划分成多个层次，是为了提高数据库的逻辑独立性和（ ）。","chooseList":[{"title":"物理独立性","index":0,"selected":false},{"title":"操作独立性","index":1,"selected":false},{"title":"安全性","index":2,"selected":false},{"title":"管理规范性","index":3,"selected":false}],"mode":0,"answer":0,"parse":"数据库系统通常采用三级模式结果并且提供两级映射功能，其中的外模式/模式映射保证了数据库系统具有较高的逻辑独立性，而模式/内模式映射保证了数据库系统具有较高的物理独立性。故选A"},{"title":"下列叙述中正确的是（ ）。","chooseList":[{"title":"矩阵是非线性结构","index":0,"selected":false},{"title":"数组是长度固定的线性表","index":1,"selected":false},{"title":"对线性表只能做插入与删除运算","index":2,"selected":false},{"title":"线性表中各元素的数据类型可以不同","index":3,"selected":false}],"mode":0,"answer":1,"parse":"线性表中各元素需要具有相同的数据类型。矩阵也是一个线性表，只不过它是一个比较复杂的线性表。对线性表可以进行插入、删除和查找等运算。"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\ntypedef struct{\nchar name[9];\nchar gender;\nint score[3];\n} STU;\nvoid f(STU *a) {\nSTU b\u003d{\"huang\",\u0027f\u0027,{95,96}},*p\u003d\u0026b;\n*a\u003d*p;\na-\u003egender\u003d\u0027m\u0027;\na-\u003escore[2]\u003da-\u003escore[0]+a-\u003escore[1];\nprintf(\"%s,%c,%d,%d,%d,\",a-\u003ename,a-\u003egender,\na-\u003escore[0],a-\u003escore[1],a-\u003escore[2]);\n}\nint main(){\nSTU c\u003d{\"sun\",\u0027m\u0027,{97,98}},*d\u003d\u0026c;\nf(d);\nprintf(\"%s,%c,%d,%d,%d\",c.name,c.gender,\nc.score[0],c.score[1],c.score[2]);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"sun,m,95,96,191,sun,m,97,98,0","index":0,"selected":false},{"title":"huang,m,95,96,191,sun,m,97,98,0","index":1,"selected":false},{"title":"huang,m,95,96,191,sun,m,97,98,195","index":2,"selected":false},{"title":"huang,m,95,96,191,huang,m,95,96,191","index":3,"selected":false}],"mode":0,"answer":3,"parse":"f函数中，经过“*p\u003d\u0026b;*a\u003d*p;”操作之后a的值其实就是b的值，所以两次输出结果一样，选D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e #include\u003cstring.h\u003e\nint main() {\nchar a[6]\u003d\"0123\",*b\u003d\"++\";\nprintf(\"%d,%d\",strlen(a),\nsizeof(b));\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"4,2","index":0,"selected":false},{"title":"4,4","index":1,"selected":false},{"title":"6,2","index":2,"selected":false},{"title":"5,4","index":3,"selected":false}],"mode":0,"answer":1,"parse":"strlen函数是求字符串长度，所以strlen(a)的返回值为4，b是一个指针，sizeof求的是类型所占用的空间，在C语言中任意指针类型的变量都只占用4字节，故选B"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nchar v[4][10];\nint i;\nfor(i\u003d0;i\u003c4;i++) {\nscanf(\"%s\",v[i]);\n}\nprintf(\"%c,%s,%s,%c\",**v,*(v+1),*(v[2]+1));\nreturn 0;\n}\n程序执行时若输入\nwelcome you to beijing\u003cCR\u003e\n则输出结果是（ ）。","chooseList":[{"title":"w,you,jing,o","index":0,"selected":false},{"title":"welcome,you,jing,to","index":1,"selected":false},{"title":"w,you,eeijing,u","index":2,"selected":false},{"title":"w,xelcome,eeijing,u","index":3,"selected":false}],"mode":0,"answer":0,"parse":"v[2]指向to，+1指向o，输出的最后一个字符是o，所以选A"},{"title":"设a，b，c是整型变量且已正确赋有初值，以下选项中的赋值表达式错误的是（ ）。","chooseList":[{"title":"a\u003d(b\u003d0)\u003d8;","index":0,"selected":false},{"title":"a\u003d(b\u003d1)+c+1;","index":1,"selected":false},{"title":"a\u003db\u003dc+1;","index":2,"selected":false},{"title":"a\u003d8+(b\u003dc\u003d1);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"C语言中，常量不能作为左值，A选项中，首先计算b\u003d0，b被赋值为0，且表达式b\u003d0结果为0，然后运算(b\u003d0)\u003db,即将8赋值给常量0，这是错误的。"},{"title":"能从任意一个结点开始没有重复地扫描到所有结点的数据结构是（ ）。","chooseList":[{"title":"循环链表","index":0,"selected":false},{"title":"双向链表","index":1,"selected":false},{"title":"二叉链表","index":2,"selected":false},{"title":"有序链表","index":3,"selected":false}],"mode":0,"answer":0,"parse":"循环链表不管从哪个结点开始遍历，一定是无重复地扫描到所有结点。"},{"title":"代码编写阶段进行的软件测试是（ ）。","chooseList":[{"title":"单元测试","index":0,"selected":false},{"title":"集成测试","index":1,"selected":false},{"title":"确认测试","index":2,"selected":false},{"title":"系统测试","index":3,"selected":false}],"mode":0,"answer":0,"parse":"集成测试是测试和组装软件的过程，它是把模块在按照设计要求组装起来的同时进行测试。单元测试是对软件设计最小单位一一模块（程序单元）进行正确性检验的测试。确认测试是验证软件的功能和性能及其他特性是否满足了需求规格说明中确定的各种需求，以及软件配置是否完全正确。系统测试是实际使用环境下对计算机系统进行的一系列集成测试和确认测试。可见在代码编写阶段可进行的是单元测试，选A"},{"title":"有以下程序段\nchar *s\u003d\"\\t\\007\\0a\\n\";\nfor(;*s;s++) printf(\"!\");\n其中for循环循环的次数为（ ）。","chooseList":[{"title":"3","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"2","index":2,"selected":false},{"title":"4","index":3,"selected":false}],"mode":0,"answer":2,"parse":"\\t一次，\\007一次，遇到\\0结束，所以是两次，故选C"},{"title":"每个学校有一名校长，且不同学校的校长可以是同一个人，则实体学校和实体校长间的联系是（ ）。","chooseList":[{"title":"一对一","index":0,"selected":false},{"title":"一对多","index":1,"selected":false},{"title":"多对一","index":2,"selected":false},{"title":"多对多","index":3,"selected":false}],"mode":0,"answer":2,"parse":""},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nint a\u003d123456,b;\nwhile(a){\nb\u003da%10;\na/\u003d10;\nswitch(b) {\ndefault:printf(\"%d\",b++);\ncase 1:continue;\ncase 2:printf(\"%d\",b++);continue;\ncase 3:printf(\"%d\",b++);\ncase 4:printf(\"%d\",b++);continue;\n}\n}\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"654342","index":0,"selected":false},{"title":"234456","index":1,"selected":false},{"title":"1234456","index":2,"selected":false},{"title":"6543421","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序每次循环，都将a当前的个位数的数字赋给b，a自身除以10，switch语句当b为6,5时，执行default语句，输出65；当b\u003d4时，执行case 4，输出4；当b\u003d3是，执行case 3，case 4，输出34；当b\u003d2时，执行case 2，输出2；当b\u003d1时，执行case 1，没有输出，所以程序最终输出结果为：6543542，故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint *fun() {\nstatic int a[2]\u003d{0,1};\na[0]+\u003da[1];\na[1]+\u003da[0];\nreturn a;\n}\nint main() {\nint i,*b;\nfor(i\u003d0;i\u003c5;i++) {\nb\u003dfun();\nprintf(\"%d %d \",b[0],b[1]);\n}printf(\"\\n\");\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"1 2 3 4 5 6 7 8","index":0,"selected":false},{"title":"1 2 1 2 1 2 1 2","index":1,"selected":false},{"title":"0 1 0 1 0 1 0 1","index":2,"selected":false},{"title":"1 2 3 5 8 13 21 34","index":3,"selected":false}],"mode":0,"answer":3,"parse":"注意fun函数中的a是被static修饰的，a只会被初始化一次，而且函数结束调用a的元素依然保持上次的值，经过运算结果与D选项的答案一致，选D"},{"title":"有下列程序\n#include \u003cstdio.h\u003e\nint main() {\nchar b[] \u003d \"happynewyear\";\nprintf(\"%s%s\",\"12345678\"+4,b+8);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"52345678year","index":0,"selected":false},{"title":"5678year","index":1,"selected":false},{"title":"12345682year","index":2,"selected":false},{"title":"5678wyear","index":3,"selected":false}],"mode":0,"answer":1,"parse":"\"12345678\"+4等效于\nchar *p\u003d\"12345678\"; p+4;，对于题中的b+8也是同理，所以选B"},{"title":"C语言的逻辑表达式在特定情况下会产生“短路”现象。若有如下逻辑表达式：\nx++ \u0026\u0026 y++\n则以下叙述正确的是（ ）。","chooseList":[{"title":"若x的值为0，则y++操作被“短路”，y值不变","index":0,"selected":false},{"title":"若x的值为1，则y++操作被“短路”，y值不变","index":1,"selected":false},{"title":"若y的值为0，则\u0026\u0026运算被“短路”，y值不变","index":2,"selected":false},{"title":"若x和y的值为0，则表达式值为0，x++和y++均不被执行","index":3,"selected":false}],"mode":0,"answer":0,"parse":"逻辑运算从左至右，\u0026\u0026运算中如果左边的表达式为0，则不计算右边表达式；||运算中如果左边的表达式为1，则不计算右边表达式。A选项中先取x的值然后x加1，因为x\u003d0，所有不计算右边的表达式，故A正确"},{"title":"有如下程序\n#include\u003cstdio.h\u003e\nint main() {\nint a\u003d8,b;\nb\u003d(a\u003e\u003e3)*8;\nprintf(\"%d,%d\",a,b);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"1,8","index":0,"selected":false},{"title":"8,8","index":1,"selected":false},{"title":"0,8","index":2,"selected":false},{"title":"8,40","index":3,"selected":false}],"mode":0,"answer":1,"parse":"a的值为8，排除A、C选项；a右移三位得1，乘8得8并赋值给b，选B"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint a\u003d1;\nint func(int d) {\nint b\u003d1;\nstatic int c\u003d1;\na++;b++;++c;++d;\nreturn a+b+c+d;\n}\nint main() {\nint k,a\u003d4;\nfor(k\u003d0;k\u003c3;k++)\nprintf(\"%d,\",func(a));\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"11,13,15,","index":0,"selected":false},{"title":"11,12,13,","index":1,"selected":false},{"title":"11,14,17,","index":2,"selected":false},{"title":"11,15,19,","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序中定义了全局变量a，初值为1，func函数中有静态变量c，初值为1。a和c的值不会随函数的调用结束而不存在，所以输出结果为“11,13,15,”，选A"},{"title":"以下选项中，合法的C语言常量是（ ）。","chooseList":[{"title":"2.0Kb","index":0,"selected":false},{"title":"\"C++\u0027","index":1,"selected":false},{"title":"\"\\2.0","index":2,"selected":false},{"title":"1.01","index":3,"selected":false}],"mode":0,"answer":3,"parse":"C语言中，常量有整型常量、实型常量、字符常量和字符串常量等，整型常量和实型常量又称为数值型常量，其中整型常量只能用数字表示，不带小数点；实型常量必须用带小数点的数表示，所以A错误，D正确。"},{"title":"有以下文件打开语句：fp\u003dfopen(\"person.dat\",____);\n要求文本文件person.dat可以进行信息查找和信息的补充录入，若文件不存在还可以建立同名新文件，则下划线处应填入的是（ ）。","chooseList":[{"title":"a+","index":0,"selected":false},{"title":"w","index":1,"selected":false},{"title":"w+","index":2,"selected":false},{"title":"wb","index":3,"selected":false}],"mode":0,"answer":0,"parse":"“a+”表示对文件可读可写，添加的数据在文件末尾，文件不存在则建立文件，A选项正确；“w”表示只写，而且会清空原来的数据，若文件不存在则建立；“w+”是在“w”的基础上可以读数据；“wb”和“w”差不多，只是是以二进制的形式读取数据"},{"title":"有以下语句\ndouble *p;\np\u003d____malloc(sizeof(double));\n若要使指针p指向一个double类型的动态存储单元，在下划线处应填入的是（ ）。","chooseList":[{"title":"double","index":0,"selected":false},{"title":"double*","index":1,"selected":false},{"title":"(*double)","index":2,"selected":false},{"title":"(double*)","index":3,"selected":false}],"mode":0,"answer":3,"parse":"ANSI C标准规定malloc函数的返回值类型是void*，要是指向double类型的动态存储单元，需要使用强制类型转换double*，故选D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nunsigned char ch\u003d0x0f;\nunsigned char a,b;\na\u003dch\u003e\u003e2;\nb\u003dch\u003c\u003c4;\nprintf(\"%d %d\\n\",a,b);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"3 15","index":0,"selected":false},{"title":"3 -16","index":1,"selected":false},{"title":"3 240","index":2,"selected":false},{"title":"3 16","index":3,"selected":false}],"mode":0,"answer":2,"parse":"在C语言中，“\u003e\u003e”是右移运算符，“\u003c\u003c”是左移运算符；程序定义字符变量ch，并赋初值为0x0f（对应的二进制是0000 1111）；ch右移两位变成00000011（3），ch左移四位变成1111 0000（240），故选C"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\ntypedef struct{\nint num;\nchar name[10];\nint score;\n} PER;\nvoid fun(PER x[]) {\nint t;\nif(x[0].score\u003ex[1].score) {\nt\u003dx[0].score;\nx[0].score\u003dx[1].score;\nx[1].score\u003dt;\n}\n}\nint main() {\nPER s[2]\u003d{{1001,\"zhang\",621,{1002,\"wang\",585}};\nint i;\nfun(s);\nfor(i\u003d0;i\u003c2;i++)\nprintf(\"%d,%s,%d,\",s[i].num,s[i].name,\ns[i].score);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"1001,zhang,585,1002,wang,621,","index":0,"selected":false},{"title":"1001,zhang,621,1002,wang,585,","index":1,"selected":false},{"title":"1002,wang,585,1001,zhang,621,","index":2,"selected":false},{"title":"1002,wang,621,1001,zhang,585,","index":3,"selected":false}],"mode":0,"answer":0,"parse":"fun函数的功能是把成绩低的放前面，所以排除B、D选项；第一个学生的名字是“zhang”，故选A"},{"title":"有下列程序\n#include\u003cstdio.h\u003e\nint main() {\nint x\u003d4,y\u003d2,z1,z2;\nz1\u003dx\u003e\u003ey;\nz2\u003dx\u003c\u003cy;\nprintf(\"%d,%d\\n\",z1,z2);\nreturn 0;\n}\n程序执行后的输出结果是（ ）。","chooseList":[{"title":"16,16","index":0,"selected":false},{"title":"16,1","index":1,"selected":false},{"title":"1,1","index":2,"selected":false},{"title":"1,16","index":3,"selected":false}],"mode":0,"answer":3,"parse":"x左移2位得1，x右移2位16，选D"}]}