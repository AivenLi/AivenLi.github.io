{"code":0,"msg":"success","data":[{"title":"对数据库数据的存储方式和物理结构的逻辑进行描述的是（ ）。","chooseList":[{"title":"模式","index":0,"selected":false},{"title":"内模式","index":1,"selected":false},{"title":"外模式","index":2,"selected":false},{"title":"用户模式","index":3,"selected":false}],"mode":0,"answer":1,"parse":"数据库系统的概念模式也称模式，是数据库系统中全局数据逻辑结构的描述，全体用户的公共数据视图；外模式也称子模式或用户模式，是用户的数据视图，也就是用户所能看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据逻辑表示；内模式又称物理模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。可见对数据库数据的存储方式和物理结构的逻辑进行描述的是内模式。故选B"},{"title":"下面属于软件定义阶段任务的是（ ）。","chooseList":[{"title":"需求分析","index":0,"selected":false},{"title":"软件测试","index":1,"selected":false},{"title":"详细设计","index":2,"selected":false},{"title":"系统维护","index":3,"selected":false}],"mode":0,"answer":0,"parse":"软件生命周期分为3个阶段：软件定义阶段，任务是确定软件开发工作必须完成的目标，确定工程的可行性；软件开发阶段，任务是具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试；软件维护阶段，任务是使软件在运行中持久地满足用户的需求。需求分析属于软件定义阶段的任务。故选A"},{"title":"设顺序表的长度为n。下列排序方法中，最坏情况下比较次数小于n(n-1)/2的是（ ）。","chooseList":[{"title":"堆排序","index":0,"selected":false},{"title":"冒泡排序","index":1,"selected":false},{"title":"快速排序","index":2,"selected":false},{"title":"简单插入排序","index":3,"selected":false}],"mode":0,"answer":0,"parse":"堆排序最坏情况下比较次数为O(nlog2n)，快速排序、简单插入排序、冒泡排序最坏情况下比较次数为n(n-1)/2。故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\n#define S(x) (x/x)*x\nint main() {\nint k \u003d 6, j \u003d 3;\nprintf(\"%d,%d\\n\", S(k+j), S(j+k));\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"57,39","index":0,"selected":false},{"title":"57,57","index":1,"selected":false},{"title":"9,9","index":2,"selected":false},{"title":"39,39","index":3,"selected":false}],"mode":0,"answer":0,"parse":"S(k+j)和S(j+k)展开分别为：“(k+j/k+j)*k+j”和“(j+k/j+k)*j+k”，前者得57，后者的39，故选A"},{"title":"将实体-联系模型转换为关系模型时，实体之间多对多联系在关系模型中的实现方式是（ ）。","chooseList":[{"title":"建立新的关系","index":0,"selected":false},{"title":"建立新的属性","index":1,"selected":false},{"title":"增加新的关键字","index":2,"selected":false},{"title":"建立新的实体","index":3,"selected":false}],"mode":0,"answer":0,"parse":"将实体-联系模型转换为关系模型时，一个m：n的联系可以转换为一个独立的关系模型，与该联系相连的各实体的码及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。故选A"},{"title":"定义学生、教师和课程的关系模式S(S#,Sn,Sd,Dc,SA)（其属性分别为学号、姓名、所在系、所在系的系主任、年龄）；C(C#,Cn,P#)（其属性分别为课程号、课程名和选修课）；SC(S#,C#,G)（其属性分别为学号、课程号和成绩）。包含对非主属性部分依赖的关系是（ ）。","chooseList":[{"title":"S(S#,Sn,Sd,Dc,SA)","index":0,"selected":false},{"title":"C(C#,Cn,P#)","index":1,"selected":false},{"title":"SC(S#,C#,G)","index":2,"selected":false},{"title":"以上三项均不是","index":3,"selected":false}],"mode":0,"answer":0,"parse":"若X-\u003eY，但Y不完全函数依赖于X，则称Y对X部分函数依赖。关系模式S中，（S#,Sd)-\u003eDc，Sd-\u003eDc,Dc不完全依赖于Sd且Sd为非主属性。故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint f(int n);\nint main() {\nint a \u003d 3, s;\ns \u003d f(a); s \u003d s+f(a);\nprintf(\"%d\\n\", s);\nreturn 0;\n}\nint f(int n) {\nstatic int a \u003d 1;\nn +\u003d a++;\nreturn n;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"7","index":0,"selected":false},{"title":"8","index":1,"selected":false},{"title":"9","index":2,"selected":false},{"title":"10","index":3,"selected":false}],"mode":0,"answer":2,"parse":"首先main函数中的局部变量a和f()函数中的静态变量a的作用域都只限在其所在的函数中，相互之间不影响，看作两个不同的变量即可；另外f()函数中静态局部变量a只在第一次调用f()函数时初始化一次，其他调用都会保留上一次调用结束时的值；分析main函数可知，第一次调用时将f(a)的返回值赋给s，所以语句可以改写为：s\u003df(a)+f(a)，即main函数中调用两次f(a)，传入的参数a取值都为3，第一次调用时，静态局部变量初始化为1，所以n\u003d4并返回，a自增为2；第二次调用时静态局部变量a取上一次调用结束时的值2，所以n\u003d5并返回，a自增为3；所以在main函数中，s\u003d4+5\u003d9，所以函数执行完输出结果为9，故选C"},{"title":"某二叉树共有13个结点，其中有4个度为1的结点，则叶子结点数为（ ）。","chooseList":[{"title":"2","index":0,"selected":false},{"title":"3","index":1,"selected":false},{"title":"4","index":2,"selected":false},{"title":"5","index":3,"selected":false}],"mode":0,"answer":3,"parse":"在树结构中，一个结点所拥有的后继个数称为该结点的度。对任何一个棵二叉树，度为0的结点（即叶子结点）总是比度为2的结点多一个。二叉树中有13个结点，设叶子结点个数为n0，度为1的结点个数为4，设度为2的结点个数为n2。则有13\u003dn0+4+n2，且n0\u003dn2+1，解得n0\u003d5，n2\u003d4。故选D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nchar s[][6] \u003d {\"abcd\", \"abc\", \"ab\" };\nint i;\nfor ( i \u003d 0; i \u003c 3; i++ ) puts(s[i]);\nreturn 0;\n}\n执行后的输出结果是（ ）。","chooseList":[{"title":"abcd\nabc\nab\n","index":0,"selected":false},{"title":"abcd\nbcd\ncd\n","index":1,"selected":false},{"title":"a\na\na\n","index":2,"selected":false},{"title":"a\nb\nc\n","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序初始化一个二维数组，其中每个元素都是一个字符数组，for循环中使用字符串输出函数puts函数打印数组中的每个元素，puts函数接受字符数组名当做参数，将该字符数组存储的字符打印出来，程序中s[0]存储的字符串是“abcd”，s[1]存储的字符串是“abc”，s[2]存储的字符串是“ab”，故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main(){\nint b[3][3]\u003d{0,1,2,0,1,2,0,1,2},i,j,t\u003d1;\nfor(i\u003d0;i\u003c3;i++)\nfor(j\u003di;j\u003c\u003di;j++) t+\u003db[i][b[j][i]];\nprintf(\"%d\\n\",t);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"0","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"3","index":2,"selected":false},{"title":"4","index":3,"selected":false}],"mode":0,"answer":3,"parse":"分析程序可以发现，内层for循环每次只执行一次：即当j\u003di时。所以可以使用i替换j，去掉for循环，对应外层for循环的i，执行t+\u003db[i][b[i][i]]，所以当i取值0、1、2时，t的值累加b[0][b[0][0]]、b[1][b[1][1]]、b[2][b[2][2]]，即b[0][0]、b[1][1]、b[2][2]，对应的值为：0、1、2，t取值为4（t初始值为1）。故选D"},{"title":"程序测试的目的是（ ）。","chooseList":[{"title":"执行测试用例","index":0,"selected":false},{"title":"发现程序中的错误","index":1,"selected":false},{"title":"发现并改正程序中的错误","index":2,"selected":false},{"title":"诊断和改正程序中的错误","index":3,"selected":false}],"mode":0,"answer":1,"parse":"测试的目的是发现软件中的错误，但是，暴露错误并不是软件测试的最终目的，测试的根本目的是尽可能多地发现并排除软件中隐藏的错误，故选B"},{"title":"在数据库管理系统提供的数据语言中，负责数据模式定义的是（ ）。","chooseList":[{"title":"数据定义语言","index":0,"selected":false},{"title":"数据管理语言","index":1,"selected":false},{"title":"数据操纵语言","index":2,"selected":false},{"title":"数据控制语言","index":3,"selected":false}],"mode":0,"answer":0,"parse":"数据库管理系统提供了相应的数据语言，它们是：数据定义语言，该语言负责数据的模式定义与数据的物理存取构建；数据操纵语言，该语言负责数据的操纵，包括增删查改等操作；数据控制语言，该语言负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能。故选A"},{"title":"下列选项中，不是面向对象主要特征的是（ ）。","chooseList":[{"title":"复用","index":0,"selected":false},{"title":"抽象","index":1,"selected":false},{"title":"继承","index":2,"selected":false},{"title":"封装","index":3,"selected":false}],"mode":0,"answer":0,"parse":"面向对象的主要特征有抽象、继承、封装和多态等。故选A"},{"title":"下面属于系统软件的是（ ）。","chooseList":[{"title":"杀毒软件","index":0,"selected":false},{"title":"财务管理系统","index":1,"selected":false},{"title":"编辑软件Word","index":2,"selected":false},{"title":"数据库管理系统","index":3,"selected":false}],"mode":0,"answer":3,"parse":"计算机软件按功能分为应用软件、系统软件、支撑软件（或工具软件）。系统软件是管理计算机的资源，提高计算机的使用效率，为用户提供各种服务的软件，如操作系统、数据库管理系统、编译程序、汇编程序和网络软件等。故选D"},{"title":"流程图是描述算法的很好的工具，一般的流程图中由几种基本图形组成。其中输入输出框的图形是（ ）。","chooseList":[{"title":"菱形","index":0,"selected":false},{"title":"椭圆形","index":1,"selected":false},{"title":"长方形","index":2,"selected":false},{"title":"平行四边形","index":3,"selected":false}],"mode":0,"answer":3,"parse":"算法可以用各种描述方法进行描述，目前最常用的有3种：伪代码、流程图和N-S结构图。其中流程图用平行四边形表示输入/出框，用长方形表示处理框，用菱形表示判断框、长方形两端为半圆的图形表示起止框，故选D"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nint fun(int a) {\nint b \u003d 2;\nstatic int c \u003d 2;\nb++; c--; return (a+b+c);\n}\nint main() {\nint k, a \u003d 2;\nfor ( k \u003d 0; k \u003c 3; k++ ) printf(\"%d\", fun(a));\nprintf(\"\\n\");\nreturn 0;\n}\n执行后的输出结果是（ ）。","chooseList":[{"title":"678","index":0,"selected":false},{"title":"666","index":1,"selected":false},{"title":"654","index":2,"selected":false},{"title":"456","index":3,"selected":false}],"mode":0,"answer":2,"parse":"静态变量的值一直存在直到程序结束，每次保留上一次调用之后的值。main函数中a的值一直不发生变化，fun函数中的静态变量c每次减一，所以每次调用的返回值都比上一次调用的返回值小1，故选C"},{"title":"若有以下函数\nint fun(char *a, char *b) {\nint bk \u003d 0;\nwhile ( (*a !\u003d \u0027\\0\u0027 ) \u0026\u0026 (*b !\u003d \u0027\\0\u0027) \u0026\u0026 strlen(a) \u003d\u003d strlen(b) ) {\nif ( *b !\u003d *a ) { bk \u003d 0; break; }\na++; b++; bk \u003d 1;\n}return bk;\n}\n此函数的功能是（ ）。","chooseList":[{"title":"判断a和b两个字符串是否相等","index":0,"selected":false},{"title":"将字符串a改名为字符串b","index":1,"selected":false},{"title":"将字符串变量a的值赋给字符串变量b","index":2,"selected":false},{"title":"检查字符串a和b中是否有\u0027\\0\u0027","index":3,"selected":false}],"mode":0,"answer":0,"parse":"分析程序可知：函数fun在字符指针a和b未遇到字符\u0027\\0\u0027且a指向的字符串A长度与b指向的字符串B长度相同时，遍历A、B，逐个比较a指向的字符与b指向的字符是否相同，所以程序分三种情况：1、A的长度与B的长度不同，返回值为0；2、A的长度等于B的长度，但A中某个位置i上的字符与B中位置i上的字符不同，返回值为0；3、A的长度等于B的长度，且A中相同位置上的字符与B中相同位置上的字符全部相同，返回值1；由此可知函数的功能是判断a和b指向的两个字符串是否相等。故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main(){\nint x,y\u003d0,z\u003d0,t;\ndo {\nscanf(\"%d\", \u0026x);\nt\u003dx\u003e0;\nswitch(t){\ncase 0: break;\ncase 1:y+\u003dx;continue;\n}\nz+\u003dx;\n} while(x);\nprintf(\"%d,%d\\n\",y,z);\nreturn 0;\n}\n程序运行时输入：-1 1 -2 2 0\u003cCR\u003e\n则输出结果是（ ）。","chooseList":[{"title":"1,1","index":0,"selected":false},{"title":"1,0","index":1,"selected":false},{"title":"3,-3","index":2,"selected":false},{"title":"3,0","index":3,"selected":false}],"mode":0,"answer":2,"parse":"分析程序结构，在do-while循环中，嵌套一个switch语句中两个case语句分别执行break和continue，其中语句是跳出switch语句，接着执行do-while循环剩下的部分；而continue语句是直接进入do-while的下一个循环，由此可知每次循环，当t\u003d0时，执行break，接着将z值累加；当t\u003d1时，执行continue语句，将y值累加x，所以当x输入-1、-2、0时，t\u003d0，z值累加为-3；当输入1、2时，t\u003d1，y值累加为3，输出y、z的值分别为3、-3。故选C"},{"title":"程序中若有以下的说明定义和语句：\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n struct STR {\nchar num[10]; int s;\n};\nint main() {\nstruct STR t, *p;\np \u003d \u0026t;\nreturn 0;\n}\n则不能给变量t的成员s赋整数99，给成员num赋空串的语句组是（ ）。","chooseList":[{"title":"(*p).s\u003d99;(*p).num\u003d\"\";","index":0,"selected":false},{"title":"p-\u003es\u003d99;p-\u003enum[0]\u003d0;","index":1,"selected":false},{"title":"(*p).s\u003d99;p-\u003enum[0]\u003d\u0027\\0\u0027;","index":2,"selected":false},{"title":"p-\u003es\u003d99;strcpy((*p).num,\"\");","index":3,"selected":false}],"mode":0,"answer":0,"parse":"结构体变量使用\u0027.\u0027运算符引用结构体成员变量，结构体指针使用\u0027-\u003e\u0027运算符引用结构体成员变量，main函数中声明结构体STR变量t，和结构体STR指针p，并将t的地址赋给p，所以使用p访问成员变量时，使用\u0027-\u003e\u0027运算符，使用p访问成员变量时，使用\u0027.\u0027运算符；另外由于成员变量num是字符数组，所以不能直接进行赋值，若要对num赋空字符串值，可以把num中第一个元素赋值为0或‘\\0\u0027，或者使用strcpy拷贝函数将空字符串\"\"拷贝到num中。"},{"title":"设栈的存储空间为S（1:60），初始状态为top\u003d61。现经过一系列正常的入栈和出栈操作后，top\u003d1，则栈中的元素个数为（ ）。","chooseList":[{"title":"0","index":0,"selected":false},{"title":"1","index":1,"selected":false},{"title":"59","index":2,"selected":false},{"title":"60","index":3,"selected":false}],"mode":0,"answer":3,"parse":"栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，出栈运算即取出栈顶元素赋予指定变量。栈为空时，栈顶指针top\u003d0，经过入栈和出栈运算，指针始终指向栈顶元素。初始状态为top\u003d61，当top\u003d1时，元素依次存储在单元1:60中，个数为60。故选D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nint k\u003d33;\nprintf(\"%d,%o,%x\\n\",k,k,k,);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"33,41,21","index":0,"selected":false},{"title":"33,33,33","index":1,"selected":false},{"title":"41,33,21","index":2,"selected":false},{"title":"33,21,41","index":3,"selected":false}],"mode":0,"answer":0,"parse":"整型常量有3种表示方法，分别是十进制数表示法、八进制数表示法和十六进制数表示法。十进制整型常量没有前缀，输出格式控制符为%d；八进制整型常量以0作为前缀，输出格式控制符为%o；十六进制整型常量以0X（或0x）作为前缀，输出格式控制符为%x。整型33用八进制表示为41，十六进制表示为21，故选A"},{"title":"设有以下代码\ndo {\nwhile(条件表达式1) 循环体A;\n} while(条件表达式2);\nwhile(条件表达式1){\ndo {\n循环体B;\n}\nwhile(条件表达式2);\n}\n其中，循环体A与循环体B相同，以下叙述正确的是（ ）。","chooseList":[{"title":"循环体A与循环体B的执行次数相同","index":0,"selected":false},{"title":"循环体A比循环体B的执行次数多一次","index":1,"selected":false},{"title":"循环体A比循环体B的执行次数少一次","index":2,"selected":false},{"title":"循环体A与循环体B的执行次数不确定","index":3,"selected":false}],"mode":0,"answer":0,"parse":"while循环语句一般形式为：while(表达式){循环体}，执行过程为：首先判断表达式，成立（非0）则执行循环体，不成立（0）则退出循环。do-while循环语句一般形式为：do{循环体}while(表达式);，执行过程为：首先执行循环体，之后判断表达式，成立则再执行一次循环体，不成立则退出循环。假设表达式1与表达式2成立次数为n1和n2。若n1\u003en2，则循环体A执行次数为n2+1，B执行次数n2+1；若n1\u003cn2，则循环体A执行次数为n1，B执行次数n1。故选A"},{"title":"设有如下定义和语句\n[1] char *s; s \u003d \"string\";\n[2] char s[7]; s \u003d \"string\";\n[3] char s[] \u003d \"string\";\n[4] char s[] \u003d {\u0027s\u0027,\u0027t\u0027,\u0027r\u0027,\u0027i\u0027,\u0027n\u0027,\u0027g\u0027};\n其中定义项可以作为字符串使用的是（ ）。","chooseList":[{"title":"[1]和[4]","index":0,"selected":false},{"title":"[1]和[2]","index":1,"selected":false},{"title":"[1]和[3]","index":2,"selected":false},{"title":"[3]和[4]","index":3,"selected":false}],"mode":0,"answer":2,"parse":"字符数组只能在初始化的时候完成赋值，否则只能对数组元素逐个赋值，[2]是错误；C语言字符串必须包含\u0027\\0\u0027字符，用来表示字符串结束，[4]错误，可以将字符串直接赋给字符指针，使得指针指向字符串首地址，[1]正确；在字符数组初始化时，可以直接使用字符串，[3]正确。故选C"},{"title":"以下程序拟读一个姓氏，查找其对应的年龄并输出\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\n struct person { char name[10]; int age; };\nstruct person group[6] \u003d {\n\"zhang\", 18,\"wang\", 20, \"li\", 19,\n\"zhao\", 18, \"liu\" 19\n}, *p;\nint main() {\nint i, flag \u003d 0;\np \u003d (struct person*)malloc(sizeof(struct person));\ngets(\u0026p-\u003ename);\nfor ( i \u003d 0; i \u003c 6; i++ )\nif ( strcmp(p-\u003ename, group[i].name) \u003d\u003d 0 ) {\nprintf(\"%d\\n\", group[i].age);\nflag \u003d 1;\n}\nif ( flag \u003d\u003d 0 ) printf(\"No find!\\n\");\n}return 0;\n}\n其中代码中有语法错误，出错的是（ ）。","chooseList":[{"title":"gets(\u0026p-\u003ename);","index":0,"selected":false},{"title":"p\u003d(struct person*);","index":1,"selected":false},{"title":"if((strcmp(p-\u003ename, group[i].name)\u003d\u003d0))","index":2,"selected":false},{"title":"printf(\"%d\\n\",group[i].age);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"语句gets(\u0026p-\u003ename)中，gets的参数应该是成员变量name数组的首地址，而\u0026p-\u003ename是首先获取数组name的首地址，然后再对首地址取地址符，所以这是错误的，正确参数应该是：gets(p-\u003ename);，故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\n#define N 4\nint main() {\nint a[N][N] \u003d {0}, i, j, k;\nfor(i \u003d 0; i \u003c N/2; i++) {\nfor(j \u003d i; j \u003c N-i; j++) a[i][j] \u003d a[N-i-1][j] \u003d i+1;\nfor(k \u003d i+1; k \u003c N-i-1; k++) a[k][j] \u003d a[k][N-i-1] \u003d i+1;\n}\nfor ( j \u003d 0; j \u003c N; j++ ) printf(\"%2d\", a[1][j]);\nprintf(\"\\n\");\nreturn 0;\n}\n执行后的输出结果是（ ）。","chooseList":[{"title":"1 2 2 1","index":0,"selected":false},{"title":"1 1 1 1","index":1,"selected":false},{"title":"2 1 1 2","index":2,"selected":false},{"title":"2 2 2 2","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题程序需要输出二维数组a中的第二行的各个元素值，即a[1]这个一维数组的元素值。分析程序可知只有在两种情况下才会对a[1]中的元素赋值：1、外层for循环中i\u003d0时，内存第二个for循环的k取值为1，此时a[k][j]\u003da[1][0]，a[k][N-i-1]\u003da[1][3]\u003d1；2、外层for循环中i\u003d1时，内层第一个for循环的j取值为1、2，a[i][j]\u003da[1][j]\u003d2，即a[1][1]\u003d2，a[1][2]\u003d2；除了这两种情况，其他情况不会修改a[1]中的值，所以最终a[1]各个元素的值为：1、2、2、1。故选A"},{"title":"若要通过位运算使整型变量a中的各位数字全部清零，以下选项正确的是（ ）。","chooseList":[{"title":"a\u003da\u00260;","index":0,"selected":false},{"title":"a\u003da|0;","index":1,"selected":false},{"title":"a\u003da^0;","index":2,"selected":false},{"title":"a\u003d!a;","index":3,"selected":false}],"mode":0,"answer":0,"parse":"任何数和0进行“与”操作结果都为0，选A"},{"title":"以下选项中能正确定义二维数组的选项是（ ）。","chooseList":[{"title":"double a[][3]\u003d{2*3};","index":0,"selected":false},{"title":"double a[][3];","index":1,"selected":false},{"title":"double a[][3]\u003d{};","index":2,"selected":false},{"title":"double a[2][3]\u003d{{1.0},{2.0},{3.0,4.0};};","index":3,"selected":false}],"mode":0,"answer":0,"parse":"B选项没有初始化，属于语法错误；C选项初始化的{}没有值，错误；D选项的外层{}内含有“;”，错误；A选项中初始的值2*3实际上是一个常量（6），定义正确。故选A"},{"title":"某二叉树的中序遍历序列为CBADE，后序遍历序列为CBADE，则前序遍历序列为（ ）。","chooseList":[{"title":"CBADE","index":0,"selected":false},{"title":"CBEDA","index":1,"selected":false},{"title":"EDABC","index":2,"selected":false},{"title":"EDCBA","index":3,"selected":false}],"mode":0,"answer":2,"parse":"二叉树遍历可以分为3种：前序遍历（访问根结点在访问左子树和右子树之前）、中序遍历（访问根结点在访问左子树和右子树两者之间）、后序遍历（访问根结点在访问左子树和右子树之后）。二叉树的中序遍历序列为CBADE，后序遍历序列为CBADE，可知该树只有左子树结点，没有右子树结点，E为根结点。中序遍历序列与后序遍历序列相同说明该树只有左子树没有右子树，因此该树有5层，从顶向下依次为EDABC，故选C"},{"title":"有定义语句\nint i; char s1[10], s2[10]\u003d\"Program\";\n则能正确给s1数组赋字符串的语句是（ ）。","chooseList":[{"title":"for(i\u003d0;i\u003c\u003d7;i++) s1[i]\u003ds2[i];","index":0,"selected":false},{"title":"s1\u003ds2;","index":1,"selected":false},{"title":"while(s2) s1++ \u003d s2++;","index":2,"selected":false},{"title":"for(i\u003d0;s2[i];i++) s1[i] \u003d s2[i];","index":3,"selected":false}],"mode":0,"answer":0,"parse":"首先字符数组只有在初始化的时候整体赋值，否则只能对字符数组逐个赋值，B错误；另外字符数组名s1、s2是常量，不能改变，C错误；字符创“Program”包含结尾的\u0027\\0\u0027，选项D中在处理到s2[i]\u003d\u0027\\0\u0027时跳出循环，未将’\\0\u0027赋给s1，D错误。由于“Program”包含结尾的\u0027\\0\u0027总共有8个字符，所以选项A是正确的，故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\n struct S {\nint a, b;\n} data[2] \u003d {10, 100, 20, 200};\nint main() {\n struct S p \u003d data[1];\nprintf(\"%d\\n\", ++(p.a));\nreturn 0;\n}\n程序运行后的结果是 （ ）。","chooseList":[{"title":"10","index":0,"selected":false},{"title":"11","index":1,"selected":false},{"title":"20","index":2,"selected":false},{"title":"21","index":3,"selected":false}],"mode":0,"answer":3,"parse":"数组data包含两个元素，元素类型为结构体S，分别为data[0]，data[1]，初始化时，使用四个整数10,100,20,200分别给data[0].a、data[0].b和data[1].a、data[1].b赋值，又p.a\u003ddata[1].a；等于20，在输出之前执行自身加1操作，所以结果为21。故选D"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nint a;\na\u003d(int)(-1.53*3);\nprintf(\"%d\\n\",a);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"-5","index":0,"selected":false},{"title":"-4","index":1,"selected":false},{"title":"-3","index":2,"selected":false},{"title":"不能确定","index":3,"selected":false}],"mode":0,"answer":1,"parse":"-1.53*3\u003d-4.59，将其转换为int类型的数值，舍去小数部分得-4，故选B"},{"title":"若有函数定义如下\nint fun(int x,int y) {\nreturn x-y; }\n则以下设计上述函数的说明语句错误的是（ ）。","chooseList":[{"title":"int fun(int x, y);","index":0,"selected":false},{"title":"int fun(int, int);","index":1,"selected":false},{"title":"int fun(int a, int b);","index":2,"selected":false},{"title":"int i, fun(int x, int y);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"C语言中函数的说明形式为：类型说明符 函数名（类型 形参名1，类型 形参名2，……）；其中形参名可以省略，所以BCD选均正确，故选A"},{"title":"有以下程序\n#include\u003cstdio.h\u003e\nint main() {\nFILE *fp;\n int i, a[6] \u003d {1,2,3,4,5,6},k;\nfp \u003d fopen(\"data.dat\",\"w+b\");\nfwrite(\u0026a[0], sizeof(int), 1, fp);\nfor ( i \u003d 0; i \u003c 6; i++ ) {\nfseek(fp, 0L, 0);\nfwrite(\u0026a[i], sizeof(int), 1, fp);\n}\nfseek(fp, 0L, 0);\nfread(\u0026k, sizeof(int), 1, fp);\nfclose(fp);\nprintf(\"%d\\n\", k);\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"123456","index":0,"selected":false},{"title":"21","index":1,"selected":false},{"title":"6","index":2,"selected":false},{"title":"654321","index":3,"selected":false}],"mode":0,"answer":2,"parse":"首先使用fopen函数以只写方式打开文件data.dat，返回文件指针fp，然后通过调用fwrite函数，将起始地址为\u0026a[0]，单位长度为sizeof(int)的一个元素写入文件，即写入a[0]；接着for循环从数组a的第二个元素起，每次首先使用fseek函数将指针fp定位到文件data.dat的开始位置，写入起始地址\u0026a[i]，单位长度为sizeof(int)的一个元素，即写入a[i]。循环结束后，使用fseek函数再将指针fp定位到文件开始位置，调用fread函数，从fp所指位置读取单位长度为sizeof(int)的一个元素到变量k中，即k\u003d6，故选C"},{"title":"结构化程序包括的基本控制结构是（ ）。","chooseList":[{"title":"主程序与子程序","index":0,"selected":false},{"title":"选择结构、循环结构和层次结构","index":1,"selected":false},{"title":"选择结构、顺序结构和循环结构","index":2,"selected":false},{"title":"输入、处理、输出","index":3,"selected":false}],"mode":0,"answer":2,"parse":"结构化程序包括的基本控制结构只有三种，即顺序、选择和循环结构，故选C"},{"title":"以下叙述中正确的是（ ）。","chooseList":[{"title":"当对文件的读/写操作完成后，必须将它关闭，否则可能导致数据丢失","index":0,"selected":false},{"title":"打开一个已存在的文件并进行了写操作后，原有文件中的全部数据必定被覆盖","index":1,"selected":false},{"title":"在一个程序中当对文件进行了写操作后，必须先关闭该文件然后再打开，才能读到第一个数据","index":2,"selected":false},{"title":"C语言中的文件是流式文件，因此只能顺序存取数据","index":3,"selected":false}],"mode":0,"answer":0,"parse":"文件一旦使用完毕，应该使用关闭文件函数文件关闭，以免文件数据丢失等错误，所以A选项正确；若使用fopen打开文件函数打开文件时，指定打开方式\u0027a\u0027，则可以向文件追加数据，而不是覆盖原文件内容，B错误；在文件被打开后，使用文件定位函数rewind或fseek函数，可以将文件指针移动到文件的任何位置，所以在写操作完成后，可以直接将文件指针定位到文件首，接着读数据，而不需要先关闭文件，再打开读取，C错误；使用文件定位函数可以随机读写文件，D错误。故选A"},{"title":"在关系A(S,SN,D)和B(D,CN,NM)中，A的主关键字是S，B的主关键字是D，则D是A的（ ）。","chooseList":[{"title":"外键（码）","index":0,"selected":false},{"title":"候选键（码）","index":1,"selected":false},{"title":"主键（码）","index":2,"selected":false},{"title":"元组","index":3,"selected":false}],"mode":0,"answer":0,"parse":"二维表中的一行称为元组。候选键（码）是二维表中能唯一标识元组的最小属性集。若一个二维表有多个候选码，则选定其中一个作为主键（码）供用户使用。表M中的某属性集是表N的候选键或主键，则称该属性集为表M的外键（码）。A中属性集D是B的主关键字，故D是A的外键（码），故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\nint main() {\nFILE *p;\nchar ch, str[5];\nif ( (fp\u003dfopen(\"file.txt\", \"wb+\")) \u003d\u003d NULL ) {\nprintf(\"error!\\n\"); exit(0);\n}\nch \u003d getchar();\nwhile ( ch !\u003d \u0027!\u0027 ) {\nfputc(ch, fp);\nch \u003d getchar();}\nrewind(fp);\ndo {\nfgets(str, 4, fp);\nputs(str);\n}\nwhile ( !feof(fp) );\nfclose(fp);\nreturn 0;\n}\n程序运行时输入：c:\\\\test!\u003cCR\u003e，则程序的输出结果是（ ）。","chooseList":[{"title":"c:\\\n\\te\nst","index":0,"selected":false},{"title":"c:\\test","index":1,"selected":false},{"title":"c:tes\nt","index":2,"selected":false},{"title":"c:\\t\nest","index":3,"selected":false}],"mode":0,"answer":0,"parse":"分析程序可知，程序是首先以只写方式打开文件file.txt，然后使用getchar函数逐个读入输入的字符，写到文件file.txt中，直到输入的字符是\u0027!\u0027，停止写入文件；然后使用rewind函数将文件指针定位到文件开头位置，再调用fgets函数，将文件中的内容读入str字符数组中，再用puts输出结果，直到遇到文件结束符，关闭文件。\n其中写入文件时是逐个写入的，而读出时调用fgets(str, 4, fp);，可知fgets至多读取3个字符到str，然后在结尾自动加上\u0027\\0\u0027字符，作为字符串的结尾标志，使用puts输出时，输出三个字符并完成换行，所以结果为A选项的内容，故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\nint fun(int n) {\nint *p;\np \u003d (int*)malloc(sizeof(int));\n*p \u003d n;\nreturn *p;\n}\nint main() {\nint a;\na \u003d fun(10);\nprintf(\"%d\\n\", a+fun(10));\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"0","index":0,"selected":false},{"title":"10","index":1,"selected":false},{"title":"20","index":2,"selected":false},{"title":"出错","index":3,"selected":false}],"mode":0,"answer":2,"parse":"由main函数可知：程序需要打印出变量a与fun(10)返回值相加的结果，而变量a的值等于fun(10)的返回值，所以最终结果取决于fun(10)的返回值。在函数fun中，传入整型参数n，定义整型变量指针p，并使用malloc函数为指针p分配了内存空间，接着将参数n的值赋给p指针所指的整型对象，并返回p指针所指对象，由此可知，函数返回值等于传入的参数n，所以fun(10)的返回值为10，且a\u003d10，最终结果为20。故选C"},{"title":"C语言的常量包括数值型常量和符号常量，以下叙述正确的是（ ）。","chooseList":[{"title":"数值型常量1.0和1所占内存的大小不同","index":0,"selected":false},{"title":"不能用sizeof求数值型常量所占内存的大小","index":1,"selected":false},{"title":"不能用sizeof求符号常量所占内存的大小","index":2,"selected":false},{"title":"可以用\u0026A取得符号常量A所占内存的首地址","index":3,"selected":false}],"mode":0,"answer":0,"parse":"整型常量：用不带小数点的数字表示。实型常量：用带小数点的数字表示。字符型常量：用带有单引号的字符表示。A选项中1.0（1.0后没有f，是double类型）位实型常量，所占内存为8字节，1位整型常量，所占内存为4字节，A选项正确，故选A"},{"title":"下列叙述中正确的是（ ）。","chooseList":[{"title":"在循环队列中，队尾指针的动态变化决定队列的长度","index":0,"selected":false},{"title":"在循环队列中，队头指针和队尾指针的动态变化决定队列的长度","index":1,"selected":false},{"title":"在带链的栈中，栈顶指针的动态变化决定栈中元素的个数","index":2,"selected":false},{"title":"在带链的队列中，队头指针与队尾指针的动态变化决定队列的长度","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在栈中，栈底保持不变，有元素入栈，栈顶指针增加；有元素出栈，栈顶指针减小。在循环队列中，队头指针和队尾指针的动态变化决定队列的长度。在循环链表中，前一个结点指向后一个结点，而最后一个结点指向头结点，只有头结点是固定的。线性链表中，由于前一个结点包含下一个结点的指针，尾结点指针为空，要插入元素，只需要改变相应位置的结点指针即可，头指针和尾指针无法决定链表的长度，故选B"}]}