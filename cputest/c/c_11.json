{"code":0,"msg":"success","data":[{"title":"有以下程序\n#include \u003cstdio.h\u003e\nstruct S { int a; int *b; };\nint main() {\nint x1[] \u003d { 3, 4 }, x2[] \u003d { 6, 7 };\nstruct S x[] \u003d 1, x1, 2, x2 };\nprintf(\"%d,%d\\n\", *x[0].b, *x[1].b);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"1,2","index":0,"selected":false},{"title":"3,6","index":1,"selected":false},{"title":"4,7","index":2,"selected":false},{"title":"变量的地址值","index":3,"selected":false}],"mode":0,"answer":1,"parse":"*x[0].b表示取结构体数组变量x的第一个元素的成员b的第一个元素的值，通过初始化可以得知该值为3，同理可推出另一个为6。故选B"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\ntypedef struct {\nchar name[10];\nchar sex;\nint age;\n} STU;\nvoid fun(STU *t) {\nstrcpy((*t).name, \"Tong\");\n(*t).age++;\n}\nint main() {\nSTU s[2] \u003d { \"Hua\", \u0027m\u0027, 18, \"Qin\", \u0027f\u0027, 19 };\nfun(s+1);\nprintf(\"%s,%d,%s,%d\\n\",\ns[0].name,s[0].age,s[1].name,s[1].age);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"Hua,18,Tong,20","index":0,"selected":false},{"title":"Hua,18,Qin,19","index":1,"selected":false},{"title":"Tong,19,Qin,19","index":2,"selected":false},{"title":"Hua,19,Tong,19","index":3,"selected":false}],"mode":0,"answer":0,"parse":"函数fun的形参是指针，通过指针修改了实参的值。故选A"},{"title":"有如下程序\n#include \u003cstdio.h\u003e\nint main() {\nint i \u003d 1;\nfor ( printf(\"%d\", i); i \u003c 4; i++ )\nprintf(\"%d\", i);\nprintf(\"\\n\");\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"1123","index":0,"selected":false},{"title":"123","index":1,"selected":false},{"title":"0123","index":2,"selected":false},{"title":"001","index":3,"selected":false}],"mode":0,"answer":0,"parse":""},{"title":"有以下程序段\nscanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c);\nif ( a \u003e b ) a \u003d b;\nif ( a \u003e c ) a \u003d c;\nprintf(\"%d\\n\", a);\n该程序段的功能是（ ）。","chooseList":[{"title":"输出a、b、c中的最小值","index":0,"selected":false},{"title":"输出a、b、c中的最大值","index":1,"selected":false},{"title":"输出a的原始值","index":2,"selected":false},{"title":"输出a、b、c中值相等的数值","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序执行过程为：从键盘读入三个整型数据，依次赋给a，b，c，判断a\u003eb，若成立将较小的值b赋值给较大的值a，判断a\u003ec，若成立将较小的值c赋值给较大的值a，if实现了将从键盘读入的数据中最小值赋给a的功能，最后输出a，也即输出最小值。故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\nint main() {\nchar *p1, *p2;\np1 \u003d p2 \u003d (char*)malloc(sizeof(char)*10);\nstrcpy(p1,\"malloc\");\nstrcpy(p2,p1+1);\nprintf(\"%c%c\\n\", p1[0], p2[0]);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"aa","index":0,"selected":false},{"title":"ma","index":1,"selected":false},{"title":"am","index":2,"selected":false},{"title":"mm","index":3,"selected":false}],"mode":0,"answer":0,"parse":"从代码中可以看出p1和p2指向的是同一个地址，第二个strcpy函数执行之后该内存区域的值为“alloc”，然后输出p1和p2的首地址的值（同一个），所以输出aa。故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nint main() {\nchar *mm[4] \u003d { \"abcd\", \"1234\", \"mnop\", \"5678\" };\nchar **pm \u003d mm;\nint i;\nfor ( i \u003d 0; i \u003c 4; i++ ) printf(\"%s\", pm[i]+i);\nprintf(\"\\n\");\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"abcd1234mnop5678","index":0,"selected":false},{"title":"abcd234op8","index":1,"selected":false},{"title":"a2o8","index":2,"selected":false},{"title":"a1m5","index":3,"selected":false}],"mode":0,"answer":1,"parse":"程序的执行过程：定义指针数组mm，长度为4，并为其初始化为4个字符串。定义指向指针的指针pm，并为其初始化为指针数组首地址。for循环依次输出4个字符串，第i个字符串从第i个下标开始输出到字符串结束，即第一个字符串输出abcd，第二个字符串输出234，第三个字符串输出op，第四个字符串输出8。故选B"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nint fun(char *s) {\nchar *p \u003d s;\nwhile ( *p++ !\u003d \u0027\\0\u0027 );\nreturn ( p - s );\n}\nint main() {\nchar *p \u003d \"01234\";\nprintf(\"%d\\n\", fun(p));\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"6","index":0,"selected":false},{"title":"5","index":1,"selected":false},{"title":"4","index":2,"selected":false},{"title":"3","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序的执行过程为：定义字符串指针p并为其初始化为“01234”，调用函数fun(p)，将指针p传入函数。while循环找到字符串的结束地址，然后使这个指针指向结束符下一个单元，结束循环。返回字符串首地址与结束符下一个地址之差，也即是字符串长度加1，输出地址差为6。故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nvoid fac2(int);\nvoid fac1(int n) {\nprintf(\"*\");\nif ( n \u003e 0 ) fac2(n-1);\n}\nvoid fac2(int n) {\nprintf(\"#\");\nif ( n \u003e 0 ) fac2(--n);\n}\nint main() {\nfac1(3);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"*###","index":0,"selected":false},{"title":"*##*","index":1,"selected":false},{"title":"**##","index":2,"selected":false},{"title":"*#*#","index":3,"selected":false}],"mode":0,"answer":0,"parse":"函数fac1中调用fac2，而fac2递归调用自身。fac1(3)，输出*，3大于0，调用fac2(2)，输出#，2大于0，调用fac2(1)，输出#，1大于0，调用fac2(0)，输出#，0不大于0，返回fac2(1)，再返回fac2(2)，再返回fac1(3)，返回main，结束。故选A"},{"title":"有如下程序\n#include \u003cstdio.h\u003e\nint main() {\nif ( \u0027\\0\u0027 \u003d\u003d 0 ) putchar(\u0027X\u0027);\nif ( \u00270\u0027 \u003d\u003d 0 ) putchar(\u0027Y\u0027);\nif ( \u0027a\u0027 \u003e \u0027b\u0027 ) putchar(\u0027Z\u0027);\nprintf(\"\\n\");\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"X","index":0,"selected":false},{"title":"XYZ","index":1,"selected":false},{"title":"YZ","index":2,"selected":false},{"title":"Y","index":3,"selected":false}],"mode":0,"answer":0,"parse":"字符所占内存为一个字节，故其ASCII码值不能超过范围0~255，其中一些特殊字符\u0027\\0\u0027的ASCII码为0，字符\u00270\u0027的ASCII码为48，字符\u0027a\u0027的ASCII码值为97，字符\u0027b\u0027的ASCII码为98。putchar函数是向标准输出设备上输出一个字符。由题目可得答案为A"},{"title":"下面对软件测试和软件调试有关概念叙述错误的是（ ）。","chooseList":[{"title":"严格执行测试计划，排除测试的随意性","index":0,"selected":false},{"title":"程序调试通常也称为Debug","index":1,"selected":false},{"title":"软件测试的目的是发现错误和改正错误","index":2,"selected":false},{"title":"设计正确的测试用例","index":3,"selected":false}],"mode":0,"answer":2,"parse":"软件测试就是在软件投入运行之前，尽可能多地发现软件中的错误，但改正错误又调试完成，C错误；软件测试应在测试之前指定测试计划，并严格执行，排除测试随意性，并且需要设计正确的测试用例，AD叙述正确；调试（也称为Debug，排错）是作为成功测试的后果出现的步骤而调试是在测试发现错误之后排除错误的过程，B正确。故选C"},{"title":"在C语言中，以下选项中不能正确表示10*1000之值的是（ ）。","chooseList":[{"title":"1.0E4.0","index":0,"selected":false},{"title":"1.E4","index":1,"selected":false},{"title":"10E3","index":2,"selected":false},{"title":"1.0e4","index":3,"selected":false}],"mode":0,"answer":0,"parse":"实型常量用带小数点的数字表示，其值有两种表达形式，分别为十进制小数形式和指数形式。指数形式由十进制数加阶码标志“e”或“E”以及阶码（只能为整数，可以带符号）组成。指数形式中阶码必须是整型常量，而A选项中4.0是浮点数，所以A选项不能正确表示10*1000之值，BCD选项都表示正确并且值为10000。故选A"},{"title":"有如下程序\n#include \u003cstdio.h\u003e\nint main() {\nchar ch \u003d \u0027A\u0027;\nwhile ( ch \u003c \u0027D\u0027 ) {\nprintf(\"%d\", ch-\u0027A\u0027);\nch++;\n}\nprintf(\"\\n\");\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"ABC","index":0,"selected":false},{"title":"012","index":1,"selected":false},{"title":"abc","index":2,"selected":false},{"title":"123","index":3,"selected":false}],"mode":0,"answer":1,"parse":""},{"title":"有如下程序\n#include \u003cstdio.h\u003e\nint main() {\nchar ch \u003d \u0027M\u0027;\nwhile ( ch !\u003d \u0027K\u0027 ) {\nch--;\nputchar(ch);\n}\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"MN","index":0,"selected":false},{"title":"LK","index":1,"selected":false},{"title":"OP","index":2,"selected":false},{"title":"MM","index":3,"selected":false}],"mode":0,"answer":1,"parse":""},{"title":"设有定义\nstruct { int n; float x; } s[2], m[2] \u003d { {10,2.8}, {0,0.0} };\n则以下赋值语句中正确的是（ ）。","chooseList":[{"title":"s[0] \u003d m[1];","index":0,"selected":false},{"title":"s \u003d m;","index":1,"selected":false},{"title":"s.n \u003d m.n;","index":2,"selected":false},{"title":"s[2].x \u003d m[2].x;","index":3,"selected":false}],"mode":0,"answer":0,"parse":"数组名为数组首地址，地址常量之间不可以相互赋值，B错误；C选项引用结构体成员错误，数组名为地址常量不是结构体变量，不能引用成员；D选项数组越界。故选A"},{"title":"设有定义\nint a, b[10], *c \u003d NULL, *p;，则以下语句错误的是（ ）。","chooseList":[{"title":"p\u003da;","index":0,"selected":false},{"title":"p\u003db;","index":1,"selected":false},{"title":"p\u003dc;","index":2,"selected":false},{"title":"p\u003d\u0026b[0];","index":3,"selected":false}],"mode":0,"answer":0,"parse":"所有对指针变量赋值，值必须是地址值。a为整型变量不是地址值，不能赋值给指针变量，A选项错误。故选A"},{"title":"设有一个M*N的矩阵已经存放在一个M行N列的数组x中，且有以下程序段\nsum \u003d 0;\nfor ( i \u003d 0; i \u003c M; i++ ) sum +\u003d x[i][0] + x[i][N-1];\nfor ( j \u003d 1; j \u003c N-1; j++ ) sum +\u003d x[0][j] +\u003d x[0][j] + x[M-1][j];\n以上程序段计算的是（ ）。","chooseList":[{"title":"矩阵两条对角线元素之和","index":0,"selected":false},{"title":"矩阵所有不靠边元素之和","index":1,"selected":false},{"title":"矩阵所有元素之和","index":2,"selected":false},{"title":"矩阵所有靠边元素之和","index":3,"selected":false}],"mode":0,"answer":3,"parse":"程序执行过程为：第一个for循环实现对第一列和第N列求和。第二个for循环在上一个for循环结果上实现对第一行和第M行从第二个元素到第N-1个元素的求和，总体来说，就是矩阵所有靠边元素之和，D正确。故选D"},{"title":"设有定义：double x \u003d 2.12;，以下不能完整输出变量x值的语句是（ ）。","chooseList":[{"title":"printf(\"x\u003d%5.0f\\n\", x);","index":0,"selected":false},{"title":"printf(\"x\u003d%f\\n\", x);","index":1,"selected":false},{"title":"printf(\"x\u003d%lf\\n\", x);","index":2,"selected":false},{"title":"printf(\"x\u003d%0.5f\\n\", x);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"选项按照float格式输出数据，宽度为5位，保留小数0位，输出为2，不能完整输出x，故选A"},{"title":"设有定义：\nint a, b;\nfloat x, y;\n则以下选项中对语句所作的注释叙述错误的是（ ）。","chooseList":[{"title":"scanf(\"%d%d%f\", \u0026a, \u0026b); /* 多余的格式符%f完全不起作用 */","index":0,"selected":false},{"title":"scanf(\"%d%d\", \u0026a, \u0026b, \u0026x); /* 多余的输入项不能获得输入数据 */","index":1,"selected":false},{"title":"scanf(\"%d%f%d\", \u0026a, \u0026b, \u0026x); /* 输入项与格式符类型不匹配，变量b和x得不到正确的输入数据 */","index":2,"selected":false},{"title":"scanf(\"Input:%d/%d\", \u0026a, \u0026b); /* 格式串中允许加入格式符以外的字符串 */","index":3,"selected":false}],"mode":0,"answer":0,"parse":"A选项中，程序从键盘正确的读入前两个数据并且保存在指定的地址，读入第三个数据后，将其放入缓冲区，然后寻找应该存放的地址，因为没有找到，程序会发生错误而中断，A选项注释错误。故选A"},{"title":"以下能正确进行字符串赋值的语句组是（ ）。","chooseList":[{"title":"char *ch; ch \u003d \"abc\";","index":0,"selected":false},{"title":"char ch[] \u003d { \u0027a\u0027, \u0027b\u0027, \u0027c\u0027 };","index":1,"selected":false},{"title":"char ch[3] \u003d \"abc\";","index":2,"selected":false},{"title":"char ch[4];\nch \u003d \"abc\";","index":3,"selected":false}],"mode":0,"answer":0,"parse":"字符串“abc”实际上也是一个指针，所以指针ch \u003d \"abc\"正确。故选A"},{"title":"在数据库管理的三个发展阶段中，数据的共享性好且冗余度最小的是（ ）。","chooseList":[{"title":"人工管理阶段","index":0,"selected":false},{"title":"文件系统阶段","index":1,"selected":false},{"title":"数据库系统阶段","index":2,"selected":false},{"title":"面向数据应用系统阶段","index":3,"selected":false}],"mode":0,"answer":2,"parse":"数据管理技术的发展经历了3个阶段：人工管理阶段、文件系统阶段和数据库系统阶段。人工管理阶段：管理者者是人，面向的对象是某个应用程序，共享程度：无共享，冗余度大，独立性：不独立，完全依赖于程序，结构化：无结构，控制能力：由应用程序控制；文件系统阶段：管理者是文件系统，面向的对象是某个应用程序，共享程度：共享性差，冗余度大，独立性：独立性差，结构化：记录内有结构，整体无结构，控制能力：由应用程序控制；数据库系统阶段：管理者是数据库管理系统，面向的对象是现实世界，共享程度：共享性大，冗余度小，独立性：具有高度的物理独立性和一定的逻辑独立性，结构化：整体结构化，用数据模型描述，控制能力：由DBMS提供数据安全性、完整性、并发控制和恢复。故选C"},{"title":"有以下程序段\nFILE *fp;\nif ( (fp \u003d fopen(\"test.txt\", \"w\")) \u003d\u003d NULL ) {\nprintf(\"不能打开文件！\");\nexit(0);\n}\nelse printf(\"打开文件成功！\");\n若指定文件test.txt不存在，且无其他异常，则以下叙述错误的是（ ）。","chooseList":[{"title":"输出\"不能打开文件！\"","index":0,"selected":false},{"title":"输出\"成功打开文件！\"","index":1,"selected":false},{"title":"系统将按指定文件名新建文件","index":2,"selected":false},{"title":"系统将为写操作建立文本文件","index":3,"selected":false}],"mode":0,"answer":0,"parse":"以“w”方式打开文件，如果文件不存在则创建文件，但有可能创建文件失败，不过题中说明了没有其他异常，所以会创建一个名为“test.txt”的文件，即可以打开文件；A错误。故选A"},{"title":"设有定义\nint a \u003d 0, b \u003d 1, c \u003d 1;\n以下选项中，表达式值与其他三个不同的是（ ）。","chooseList":[{"title":"b \u003d a \u003d\u003d c","index":0,"selected":false},{"title":"a \u003d b \u003d c","index":1,"selected":false},{"title":"a \u003d c \u003d\u003d b","index":2,"selected":false},{"title":"a \u003d a !\u003d c","index":3,"selected":false}],"mode":0,"answer":0,"parse":"赋值运算结合性为由右向左结合，赋值运算符左值为变量，右值为变量或常量，且左右两边数据类型相同才能实现赋值。成功实现赋值后以左值为返回值。逻辑表达式成立则返回1， 不成立返回0。A选项逻辑表达式a\u003d\u003dc不成立（0），则b\u003d0，表达式值为0。B选项中将c赋值给b，b\u003d1，再讲b赋给a，a\u003d1，表达式值为1。C选项逻辑表达式c\u003d\u003db成立（1），则a\u003d1，表达式值为1。D选项逻辑表达式a!\u003dc成立（1），则c\u003d1，表达式值为1。A选项与其他选项不同。故选A"},{"title":"下面属于系统软件的是（ ）。","chooseList":[{"title":"财务管理系统","index":0,"selected":false},{"title":"编译软件","index":1,"selected":false},{"title":"编辑软件Word","index":2,"selected":false},{"title":"杀毒软件","index":3,"selected":false}],"mode":0,"answer":1,"parse":"计算机软件按功能分为应用软件、系统软件、支持软件（或工具软件）。系统软件是管理计算机的资源，提高计算机的使用效率，为用户提供各种服务的软件，如操作系统、数据库管理系统、编译程序、汇编程序和网络软件等，B正确。ACD为应用软件。"},{"title":"软件生命周期中，确定软件系统要做什么的阶段是（ ）。","chooseList":[{"title":"需求分析","index":0,"selected":false},{"title":"软件测试","index":1,"selected":false},{"title":"软件设计","index":2,"selected":false},{"title":"系统维护","index":3,"selected":false}],"mode":0,"answer":0,"parse":"软件生命周期各阶段的主要任务是：问题定义、可行性研究与计划制定、需求分析、软件设计、软件实现、软件测试、运行维护。其中需求分析是指对待开发软件的需求进行分析并给出详细定义，也即是确定软件系统要做什么。故选A"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nvoid fun(int *x, int s, int e) {\nint i, j, t;\nfor ( i \u003d s, j \u003d e; i \u003c j; i++, j-- ) {\nt \u003d *(x+i);\n*(x+i) \u003d *(x+j);\n*(x+j) \u003d t;\n}\n}\nint main() {\nint m[] \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, k;\nfun(m, 0, 3);\nfun(m+4, 0, 5);\nfun(m, 0, 9);\nfor ( k \u003d 0; k \u003c 10; k++ ) printf(\"%d\", m[k]);\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"4567890123","index":0,"selected":false},{"title":"3210987654","index":1,"selected":false},{"title":"9876543210","index":2,"selected":false},{"title":"0987651234","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序的执行过程为：定义数组m，并为其赋初值，数组长度为10。调用函数fun(m, 0, 3)将数组首地址传入函数，函数实现将数组下标值从0到3的元素首尾倒置，for循环结束之后数组为m\u003d{3,2,1,0,4,5,6,7,8,9}。调用函数fun(m+4,0,4)将数组下标值为4的元素地址传入函数，函数实现将数组下标值从4到9的元素首尾倒置，for循环结束之后数组m\u003d{3,2,1,0,9,8,6,5,4}。调用函数fun(m,0,9)将数组首地址传入函数，函数实现将数组下标值从0到9的元素首尾倒置，for循环结束之后数组为m\u003d{4,5,6,7,8,9,0,1,2,3}。故选A"},{"title":"下列关于算法复杂度叙述正确的是（ ）。","chooseList":[{"title":"最坏情况下的时间复杂度一定高于平均情况的时间复杂度","index":0,"selected":false},{"title":"时间复杂度与所用的计算工具无关","index":1,"selected":false},{"title":"对同一个问题，采用不同的算法，则它们的时间复杂度是相同的","index":2,"selected":false},{"title":"时间复杂度与采用的算法描述语言有关","index":3,"selected":false}],"mode":0,"answer":1,"parse":"算法的时间复杂度是指执行算法所需要的计算工作量，它与使用的计算机、程序设计语言以及算法实现过程中的许多细节无关，B正确；D选项错误，最坏情况下的时间复杂度可以与平均情况的时间复杂度相同，A错误；不同的算法时间复杂度一般不同，C错误。故选B"},{"title":"下列叙述中错误的是（ ）。","chooseList":[{"title":"在带链队列中，队头指针和队尾指针都是在动态变化的","index":0,"selected":false},{"title":"在带链栈中，栈顶指针和栈底指针都是在动态变化的","index":1,"selected":false},{"title":"在带链栈中，栈顶指针是在动态变化的，但栈底指针是不变的","index":2,"selected":false},{"title":"在带链队列中，队头指针和队尾指针可以指向同一个位置","index":3,"selected":false}],"mode":0,"answer":1,"parse":"栈也可以采用链式存储结构表示，把栈组织成一个单链表，这种数据结构可称为带链的栈，入栈和出栈过程中栈底指针不变，栈顶指针随之变化，B错误。故选B"},{"title":"设有n个数按从大到小的顺序存放在数组x中，以下能使这n个数在x数组中的顺序变为从小到大的是（ ）。","chooseList":[{"title":"for ( i \u003d 0; i \u003c n / 2; i++ ) {\nt \u003d x[i];\n x[i] \u003d x[n-i-1];\nx[n-i-1] \u003d t;\n}","index":0,"selected":false},{"title":"for ( i \u003d 0; i \u003c n; i++ ) {\nt \u003d x[i];\nx[i] \u003d x[n-i-1] \u003d t;\nx[n-i-1] \u003d t;\n}","index":1,"selected":false},{"title":"for ( i \u003d 0; i \u003c n / 2; i++ ) {\nt \u003d x[i];\nx[i] \u003d x[n-i+1];\nx[n-i+1] \u003d t;\n}","index":2,"selected":false},{"title":"for ( i \u003d 0; i \u003c n / 2; i +\u003d 2) {\nt \u003d x[i];\nx[i] \u003d x[n-i-1];\nx[n-i-1] \u003d t;\n}","index":3,"selected":false}],"mode":0,"answer":0,"parse":"A选项中控制变量上线为n/2，用变量t实现数下标值i与n-i-1的元素交换，使数组元素首尾倒置，从而实现从小到大排列，A正确。故选A"},{"title":"某二叉树的前序序列为ABCDEFG，中序序列为DCBAEFG，则该二叉树的后序序列为（ ）。","chooseList":[{"title":"EFGDCBA","index":0,"selected":false},{"title":"DCBEFGA","index":1,"selected":false},{"title":"BCDGFEA","index":2,"selected":false},{"title":"DCBGFEA","index":3,"selected":false}],"mode":0,"answer":3,"parse":"由题意可知A为根结点、DCB为左子树结点，EFG为右子树结点。同理B为C父结点，C为D父结点，且CD均为B的同侧子树结点。同理E为F根结点，F为G根结点，且FG为E同侧子树结点。故该二叉树的后序序列为DCBGFEA。"},{"title":"设有两行定义语句:\nint scanf;\nfloat case;\n则以下叙述正确的是（ ）。","chooseList":[{"title":"两行定义语句都不合法","index":0,"selected":false},{"title":"两行定义语句都合法","index":1,"selected":false},{"title":"第1行语句不合法","index":2,"selected":false},{"title":"第2行语句不合法","index":3,"selected":false}],"mode":0,"answer":3,"parse":"case为关键字，不可被用户重定义，所以第2行语句不合法。故选D"},{"title":"有如下程序\n#include \u003cstdio.h\u003e\nint main() {\nint a \u003d 0, b \u003d 1;\nif ( ++a \u003d\u003d b++ ) printf(\"T\");\nelse printf(\"F\");\nprintf(\"a\u003d%d,b\u003d%d\\n\", a, b);\nprintf(\"\\n\");\nreturn 0;\n}\n程序运行后的输出结果是（ ）。","chooseList":[{"title":"Ta\u003d0,b\u003d1","index":0,"selected":false},{"title":"Fa\u003d1,b\u003d2","index":1,"selected":false},{"title":"Ta\u003d1,b\u003d2","index":2,"selected":false},{"title":"Fa\u003d0,b\u003d2","index":3,"selected":false}],"mode":0,"answer":2,"parse":"程序执行过程为：判断++a\u003d\u003db++是否成立，++a前置运算先加1，则a\u003d1，b++后置运算先取值，则b\u003d1，也即是判断1\u003d\u003d1，成立，输出T，之后b\u003d2，输出a\u003d1，b\u003d2。C选项正确，故选C"},{"title":"以下不属于C语言位运算符的是（ ）。","chooseList":[{"title":"!","index":0,"selected":false},{"title":"|","index":1,"selected":false},{"title":"^","index":2,"selected":false},{"title":"~","index":3,"selected":false}],"mode":0,"answer":0,"parse":"“|”是按位或；“^”是按位异或；“~”是按位取反。“!”是逻辑运算符“非”。故选A"},{"title":"以下叙述中错误的是（ ）。","chooseList":[{"title":"书写风格良好的程序执行效率高","index":0,"selected":false},{"title":"书写风格良好的程序易读性好","index":1,"selected":false},{"title":"C程序可以在一行上写多条语句","index":2,"selected":false},{"title":"C程序允许一条语句分写在多行上","index":3,"selected":false}],"mode":0,"answer":0,"parse":"编写的代码风格和程序执行的效率没有任何关系，A错误。故选A"},{"title":"将E-R图转换为关系模式时，E-R图中的实体和联系都可以表示为（ ）。","chooseList":[{"title":"属性","index":0,"selected":false},{"title":"键","index":1,"selected":false},{"title":"关系","index":2,"selected":false},{"title":"域","index":3,"selected":false}],"mode":0,"answer":2,"parse":"采用E-R方法得到的全局概念模型是对信息世界的描述，并不适用于计算机处理，为了适合关系数据库系统的处理，必须将E-R图转换成关系模式。这就是逻辑设计的主内容。E-R图是由实体、属性和联系组成，而关系模式中只有一种元素--关系。C正确。"},{"title":"以下关于函数的叙述中正确的是（ ）。","chooseList":[{"title":"函数调用必须传递实参","index":0,"selected":false},{"title":"函数必要有形参","index":1,"selected":false},{"title":"函数必须要有返回值","index":2,"selected":false},{"title":"函数形参的类型与返回值的类型无关","index":3,"selected":false}],"mode":0,"answer":3,"parse":"函数的返回值是返回值，形参是形参，两者没有关系。D描述正确，故选D"},{"title":"下列叙述中不正确的是（ ）。","chooseList":[{"title":"在链表中，如果每个结点有两个指针域，则该链表一定是非线性结构","index":0,"selected":false},{"title":"在链表中，如果有两个结点的同一指针域的值相等，则该链表一定是非线性结构","index":1,"selected":false},{"title":"在链表中，如果每个结点有两个指针域，则该链表一定是线性结构","index":2,"selected":false},{"title":"在链表中，如果有两个结点的同一个指针域的值相等，则该链表一定是线性结构","index":3,"selected":false}],"mode":0,"answer":0,"parse":"双向链表结点有两个指针域，指向前一个结点的指针和指向后一个结点的指针，也是线性结构，A错误。故选A"},{"title":"设循环队列为Q（1：m），其初始状态为front\u003drear\u003dm。经过一系列入队与退队运算后，front\u003d20，rear\u003d15。现要在该循环队列中寻找最小值的元素，最坏情况下需要比较的次数为（ ）。","chooseList":[{"title":"5","index":0,"selected":false},{"title":"6","index":1,"selected":false},{"title":"m-5","index":2,"selected":false},{"title":"m-6","index":3,"selected":false}],"mode":0,"answer":3,"parse":"队列初始状态为front\u003drear\u003dm，当front\u003d20，rear\u003d15时，队列中有m-20+15\u003dm-5个元素，比较次数为m-6次。故选D"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nint fun(int n) {\nstatic int t \u003d 1; int i \u003d 1;\nfor ( ; i \u003c\u003d n; i++ ) t *\u003d i;\nreturn t;\n}\nint main() {\nint t \u003d 1, i;\nfor ( i \u003d 2; i \u003c 4; i++ ) t +\u003d fun(i);\nprintf(\"%d\\n\", t);\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"8","index":0,"selected":false},{"title":"11","index":1,"selected":false},{"title":"15","index":2,"selected":false},{"title":"4","index":3,"selected":false}],"mode":0,"answer":2,"parse":"static修饰的变量只会被初始化一次，函数调用结束后该变量仍然存在，值为本次调用之后的值。函数fun的功能是累积，而main函数是累和，经过计算得结果为15。故选C"},{"title":"设有以下定义\nchar s1[] \u003d \"0123\";\nchar s2[] \u003d { \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027 };\n则以下叙述正确的是（ ）。","chooseList":[{"title":"数组s1的长度小于s2的长度","index":0,"selected":false},{"title":"数组s1和s2的长度相同","index":1,"selected":false},{"title":"数组s1的长度大于s2的长度","index":2,"selected":false},{"title":"数组s1和s2完全等价","index":3,"selected":false}],"mode":0,"answer":2,"parse":"数组s1的内容实际上是：“0123\\0”，而数组s2的内容就是题中定义的内容，所以选C"},{"title":"有以下程序\n#include \u003cstdio.h\u003e\nint main() {\nint s[3][2] \u003d { 1, 2, 3, 4, 5, 6 }, *ps[3], k;\nfor ( k \u003d 0; k \u003c 3; k++ ) {\nps[k] \u003d s[k];\nprintf(\"%d\", *(ps[k]+1));\n}\nreturn 0;\n}\n程序的运行结果是（ ）。","chooseList":[{"title":"2 4 6","index":0,"selected":false},{"title":"1 3 5","index":1,"selected":false},{"title":"1 2 3","index":2,"selected":false},{"title":"4 5 6","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序执行过程为：定义二维数组s与指针数组ps，for循环实现将二维数组每一行的首地址赋值给对应的指针数组元素，然后输出二维数组每行的第二个元素。故选A"}]}