{"code":0,"msg":"success","data":[{"title":"在软件开发中，需求分析阶段产生的主要文档是（）。","chooseList":[{"title":"集成测试计划","index":0,"selected":false},{"title":"概要设计说明书","index":1,"selected":false},{"title":"可行性分析报告","index":2,"selected":false},{"title":"软件需求规格说明书","index":3,"selected":false}],"mode":0,"answer":3,"parse":"集成测试计划是在概要设计阶段编写的文档，A错误。概要设计说明书是总体设计阶段产生的文档，B错误。可行性分析阶段产生可行性分析报告，C错误。故选D。"},{"title":"有三个关系R、S和T如下：[image]由关系R和S通过运算得到关系T，则所使用的运算为（）。","chooseList":[{"title":"并","index":0,"selected":false},{"title":"交","index":1,"selected":false},{"title":"自然连接","index":2,"selected":false},{"title":"笛卡儿积","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_9.png","parse":"自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉；笛卡尔积是用R集合中元素为第一元素，S集合中元素为第二元素构成的有序树；根据关系T可以很明显的看出是从关系R与关系S中取得相同的关系组所以取得是交运算。"},{"title":"if语句的语法格式可描述为：\n格式1：if ( \u003c条件\u003e ) \u003c语句\u003e\n或\n格式2：if ( \u003c条件\u003e ) \u003c语句1\u003e\nelse \u003c语句2\u003e\n关于上面的语法格式，下列表述中错误的是（）。","chooseList":[{"title":"\u003c条件\u003e部分可以是一个if语句，例如 if ( if ( a \u003d\u003d 0 ) ...) ...","index":0,"selected":false},{"title":"\u003c语句\u003e部分可以是一个if语句，例如 if ( ... ) if ( ... ) ...","index":1,"selected":false},{"title":"\u003c语句\u003e部分可以是一个循环语句，例如 if ( ... ) while ( ... ) ...","index":2,"selected":false},{"title":"如果在\u003c条件\u003e前加上逻辑非运算符!并交换\u003c语句1\u003e和\u003c语句2\u003e的位置，语句功能不变","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查if语句，if语句的条件部分不能嵌套if语句，所以A错误；B选项就是if语句嵌套；语句部分可以是任何正确的语句，C正确；D选项其实就是将判断条件颠倒，然后执行语句也颠倒，所以效果一样。故选A"},{"title":"下列运算符不能重载为友元函数的是（）。","chooseList":[{"title":"\u003d () [] -\u003e","index":0,"selected":false},{"title":"+ - ++ --","index":1,"selected":false},{"title":"\u003e \u003c \u003e\u003d \u003c\u003d","index":2,"selected":false},{"title":"+\u003d -\u003d *\u003d /\u003d","index":3,"selected":false}],"mode":0,"answer":0,"parse":"关于运算符重载为友元函数有如下规定：1. 一般情况下，单目运算符最好重载为类的成员函数，双目运算符最好重载为类的友元函数；2. 双目运算符“\u003d、()、[]、-\u003e”不能重载为类的友元函数。故选A。"},{"title":"如下类定义：[image]其中四个函数的定义中正确的是（）。","chooseList":[{"title":"(1)","index":0,"selected":false},{"title":"(2)","index":1,"selected":false},{"title":"(3)","index":2,"selected":false},{"title":"(4)","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_25.png","parse":"本题考查常成员函数，常成员函数只能引用本类中的数据成员，而不能修改它。故选B。"},{"title":"有如下类定义：[image]其中存在语法错误的行是（）。","chooseList":[{"title":"(1)","index":0,"selected":false},{"title":"(2)","index":1,"selected":false},{"title":"(3)","index":2,"selected":false},{"title":"(4)","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_30.png","parse":"本题考查对象的初始化，类的数据成员是不能在声明类时初始化的。故选D。"},{"title":"有如下程序：[image]其中有语法错误的语句是（）。","chooseList":[{"title":"(1)和(4)","index":0,"selected":false},{"title":"(1)、(2)和(3)","index":1,"selected":false},{"title":"(1)、(2)、(3)和(4)","index":2,"selected":false},{"title":"(2)、(3)和(4)","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_35.png","parse":"本题考查保护继承中派生类对基类的访问属性，受保护继承中，基类的公用成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有，保护基类的所有成员在派生类中都被保护起来，在类外不能访问，所以1、2和3错误。故选B。"},{"title":"当使用ifstream流类定义一个流对象并打开一个磁盘文件时，文件的默认打开方式为（）。","chooseList":[{"title":"ios_base::in","index":0,"selected":false},{"title":"ios_base::out","index":1,"selected":false},{"title":"ios_base::in | ios_base::out","index":2,"selected":false},{"title":"ios_base::in \u0026 ios_base::out","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查对文件输入流的操作，ifstream流类为输入流类，默认的文件输入流打开方式为ios::in。故选A。"},{"title":"软件设计中模块划分应遵循的准则是（）。","chooseList":[{"title":"低内聚低耦合","index":0,"selected":false},{"title":"高内聚低耦合","index":1,"selected":false},{"title":"低内聚高耦合","index":2,"selected":false},{"title":"高内聚高耦合","index":3,"selected":false}],"mode":0,"answer":1,"parse":"软件设计中模块划分应遵循的准则是高内聚低耦合、模块大小规模适当、模块的依赖关系适当等。模块的划分应遵循一定的要求，以保证模块划分合理，并进一步保证以此为依据开发出的软件系统可靠性强，易于理解和维护。模块之间的耦合应尽可能的高。故选B。"},{"title":"在数据库设计中，将E-R图转换成关系数据模型的过程属于（）。","chooseList":[{"title":"需求分析阶段","index":0,"selected":false},{"title":"概念设计阶段","index":1,"selected":false},{"title":"逻辑设计阶段","index":2,"selected":false},{"title":"物理设计阶段","index":3,"selected":false}],"mode":0,"answer":2,"parse":"E-R图转换成关系模型数据则是把图形分析出来的联系反映到数据库中，即设计出表，所以属于逻辑设计阶段。故选C。"},{"title":"有如下程序：[image]编译运行程序将出现的情况是（）。","chooseList":[{"title":"运行时有可能出错","index":0,"selected":false},{"title":"运行时一定输出：The value at p：8","index":1,"selected":false},{"title":"运行时一定输出：The value at p：*8","index":2,"selected":false},{"title":"编译时出现语法错误，不能生成可执行文件","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_13.png","parse":"先定义指针变量，然后给指针变量赋初值有三种情况：\n1. 用取地址运算符：“\u0026”将变量地址赋给指针变量，如p\u003d\u0026a；\n2. 将一个指针变量中的地址赋给另一个指针变量，如p\u003dp1；\n3. 给指针变量赋空值0，如q\u003d0，表示该指针变量不指向任何变量。而不能用一个常量给指针赋初值。"},{"title":"下列有关内联函数的叙述中，正确的是（）。","chooseList":[{"title":"内联函数在调用时发生控制转移","index":0,"selected":false},{"title":"内联函数必须通过关键字inline来定义","index":1,"selected":false},{"title":"内联函数是通过编译器来实现的","index":2,"selected":false},{"title":"内联函数函数体最后一条语句必须是return语句","index":3,"selected":false}],"mode":0,"answer":2,"parse":"一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用处；而内联函数在调用时，是将调用表达式用内联函数体来替换，所以在调用时不发生控制转移。在类内部实现的函数都是内联函数，可以不用inline定义；只有函数外部定义的内联函数才必须加关键字inline。编译系统并非对内联函数必须使用内敛，而且根据情况决定。内联函数不是必须有返回值的。故选C。"},{"title":"由于常对象不能被更新，因此（）。","chooseList":[{"title":"通过常对象只能调用它的常成员函数","index":0,"selected":false},{"title":"通过常对象只能调用静态成员函数","index":1,"selected":false},{"title":"常对象的成员都是常成员","index":2,"selected":false},{"title":"通过常对象可以调用任何不改变对象值的成员函数","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查常对象的基本知识，常对象只能调用它的常成员函数，而不能调用非const函数，常对象的成员函数不一定都是常成员函数，只需要保证其数据成员是常数据成员即可。故选A。"},{"title":"有如下类定义：[image]若obj是类D的对象，则下列语句中不违反访问控制权限的是（）。","chooseList":[{"title":"obj.fun1();","index":0,"selected":false},{"title":"obj.fun2();","index":1,"selected":false},{"title":"obj.fun3();","index":2,"selected":false},{"title":"obj.fun4();","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_29.png","parse":"本题考查公用继承对基类成员得访问属性。在公用继承中，基类的公用成员和保护乘员在派生类中保持原有的访问属性，其私有成员仍为基类私有。所以在本题中，在类外引用成员函数时，派生对象之恩引用基类的公用成员函数fun1，故选A。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"ABA~A~B~A","index":0,"selected":false},{"title":"ABA~B~A~A","index":1,"selected":false},{"title":"BAA~B~A~A","index":2,"selected":false},{"title":"BAA~A~B~A","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_34.png","parse":"本题考查派生类的构造函数和析构函数，在定义一个派生类的对象时，先调用基类的构造函数，然后再执行派生类的构造函数。对象释放时，先执行派生类的析构函数，再执行基类的析构函数。故选B。"},{"title":"有如下函数模板：\ntemplate\u003ctypename, T, typename U\u003e\nT cast(U u) {\n return u;\n}\n其功能是将U类型数据转换为T类型数据。已知i为int型变量，下列对模板函数cast的调用中正确的是（）。","chooseList":[{"title":"cast(i);","index":0,"selected":false},{"title":"cast\u003c\u003e(i);","index":1,"selected":false},{"title":"cast\u003cchar *, int\u003e(i);","index":2,"selected":false},{"title":"cast\u003cdouble, int\u003e(i);","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查函数模板的基本运用，属于基础知识。函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型代表，这个通用函数就是函数模板。函数模板可以设定默认参数，这样在调用模板函数时就可以省略实参，函数模板的实例就是一个函数的定义。故选D。"},{"title":"算法的有穷性是指（）。","chooseList":[{"title":"算法程序的运行时间是有限的","index":0,"selected":false},{"title":"算法程序所处理的数据量是有限的","index":1,"selected":false},{"title":"算法程序的长度是有限的","index":2,"selected":false},{"title":"算法只能被有限的用户使用","index":3,"selected":false}],"mode":0,"answer":0,"parse":"算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。有穷性是指算法程序的运行时间是有限的。故选A。"},{"title":"设有表示学生选课的三张表，学生S（学号，姓名，性别，年龄，身份证号），课程C（课号，课名），选课SC（学号，课号，成绩），则表SC的关键字（键或码）为（）。","chooseList":[{"title":"课号，成绩","index":0,"selected":false},{"title":"学号，成绩","index":1,"selected":false},{"title":"学号，课号","index":2,"selected":false},{"title":"学号，姓名，成绩","index":3,"selected":false}],"mode":0,"answer":2,"parse":"学号是学生表S的主键，课号是课程表C的主键，所以选课表SC的关键字就应该是与前两个表能够直接联系且能唯一定义的学号和课号。故选C。"},{"title":"下列符号中，正确的C++标识符是（）。","chooseList":[{"title":"enum","index":0,"selected":false},{"title":"2b","index":1,"selected":false},{"title":"foo-9","index":2,"selected":false},{"title":"_32","index":3,"selected":false}],"mode":0,"answer":3,"parse":"在C++中，标识符不能是关键字，A错误；标识符可以包含数字，但是数字不能作为开头的字符也不能全是数字，B错误；标识符只能由大小写字母、数字和下划线命名，C错误。D选项正确。"},{"title":"有如下程序：[image]编译运行时这个程序出现的情况是（）。","chooseList":[{"title":"输出：3","index":0,"selected":false},{"title":"输出：3.0","index":1,"selected":false},{"title":"输出一个不确定的数","index":2,"selected":false},{"title":"编译出错，无法运行","index":3,"selected":false}],"mode":0,"answer":2,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_21.png","parse":"本题考查函数调用及传值方式传递参数，执行函数funciton时，并没有将数值3传回来，而val有没有初始化，所以会输出一个不确定的值，故选C。"},{"title":"下列关于this指针的描述中，正确的是（）。","chooseList":[{"title":"类的成员函数都有this指针","index":0,"selected":false},{"title":"类的友元函数都有this指针","index":1,"selected":false},{"title":"任何与类相关的函数都有this指针","index":2,"selected":false},{"title":"类的非静态成员函数都有this指针","index":3,"selected":false}],"mode":0,"answer":3,"parse":"this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员时，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。另外，全局函数和静态函数都不能使用this指针。故选D。"},{"title":"有如下类定义：[image]若执行语句\nPoint a(2), b[3], *c[4];\n则Point类的构造函数被调用的次数是（）。","chooseList":[{"title":"2","index":0,"selected":false},{"title":"3","index":1,"selected":false},{"title":"4","index":2,"selected":false},{"title":"5","index":3,"selected":false}],"mode":0,"answer":2,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_31.png","parse":"本题考查默认构造函数和带参数的构造函数，题目中定义一个对象a(2)以及对象数组b[3]，共执行4次构造函数，对象指针不调用构造函数。故选C。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"12","index":0,"selected":false},{"title":"1234","index":1,"selected":false},{"title":"21","index":2,"selected":false},{"title":"2134","index":3,"selected":false}],"mode":0,"answer":2,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_36.png","parse":"本题考查派生类的构造函数和析构函数，在定义一个派生类的对象时，先调用基类的构造函数，然后再执行派生类的构造函数，对象释放时，先执行派生类的析构函数，再执行基类的析构函数。本题中定义一个派生类对象时，分别调用基类的构造函数，所以分别输出21。故选C。"},{"title":"要建立文件流并打开当前目录下的文件file.dat用于输入，下列语句错误的是（）。","chooseList":[{"title":"ifstream fin \u003d ifstream.open(\"file.dat\");","index":0,"selected":false},{"title":"ifstream *fin \u003d new ifstream(\"file.dat\");","index":1,"selected":false},{"title":"ifstream fin;\nfin.open(\"file.dat\");","index":2,"selected":false},{"title":"ifstream *fin \u003d new ifstream();\nfin-\u003eopen(\"file.dat\");","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查对文件流输入的操作，可以调用文件流的成员函数open，一般形式如下：\n文件对象.open(磁盘文件名, 输入/输出方式)\n根据以上格式，可以判断A选项错误。故选A。"},{"title":"结构化程序设计的基本原则不包括（）。","chooseList":[{"title":"模块化","index":0,"selected":false},{"title":"多态性","index":1,"selected":false},{"title":"逐步求精","index":2,"selected":false},{"title":"自顶向下","index":3,"selected":false}],"mode":0,"answer":1,"parse":"结构化程序设计的思想包括：自顶向下、逐步求精、模块化、限制使用goto语句。故选B"},{"title":"下列关于栈的叙述正确的是（）。","chooseList":[{"title":"不能删除数据","index":0,"selected":false},{"title":"只能在栈底插入数据","index":1,"selected":false},{"title":"栈按“先进先出”的组织数据","index":2,"selected":false},{"title":"栈按“先进后出”组织数据","index":3,"selected":false}],"mode":0,"answer":3,"parse":"栈是按“先进后出”的原则组织数据的，数据的插入和删除都在栈顶进行操作。故选D"},{"title":"有如下程序：\nint x \u003d 3;\ndo {\nx -\u003d 2;\ncout \u003c\u003c x;\n} while ( !(--x) );\n执行这个程序的输出结果是（）。","chooseList":[{"title":"1","index":0,"selected":false},{"title":"1 -2","index":1,"selected":false},{"title":"3 0","index":2,"selected":false},{"title":"死循环","index":3,"selected":false}],"mode":0,"answer":1,"parse":"本题考查do-while语句，执行do-while语句时，先执行循环体内的语句，再判断while中表达式的值，表达式为非零时，返回重新执行循环体语句。在本题中。先执行循环体内的语句，输出1，然后判断表达式，为非零，且此时x为0；再次执行循环体时，输出-2，然后判断表达式为0，不执行，退出。故选B。"},{"title":"运算符重载是对已有的运算符赋予多重含义，因此（）。","chooseList":[{"title":"可以对基本类型（如int类型）的数据，重新定义“+”运算符的含义","index":0,"selected":false},{"title":"可以改变一个已有运算符的优先级和操作数个数","index":1,"selected":false},{"title":"只能重载C++中已经有的运算符，不能定义新运算符","index":2,"selected":false},{"title":"C++中已经有的所有运算符都可以重载","index":3,"selected":false}],"mode":0,"answer":2,"parse":"重载运算符的规则如下：1. C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载；2. C++不能重载的运算符只有5个（它们是：. ，.* ，:: ，sizeof和?:）；3. 重载不能改变运算符运算对象的个数；4. 重载不能改变运算符的优先级和结合性；5. 重载运算符的函数不能有默认的参数；6. 重载的运算符必须和用户定义类型的对象一起使用，至少应有一个是对象，即不允许参数全部是C++的标准类型。故选C"},{"title":"有如下类定义：[image]若要为MyClass类重载流输入运算符“\u003e\u003e”，使得程序中可以“cin \u003e\u003e obj;”的形式改变MyClass类的对象obj中数据成员data的值，则【】处的声明语句应为（）。","chooseList":[{"title":"friend istream\u0026 operator \u003e\u003e (istream\u0026 is, MyClass\u0026 a);","index":0,"selected":false},{"title":"friend istream\u0026 operator \u003e\u003e (istream\u0026 is, MyClass a);","index":1,"selected":false},{"title":"istream\u0026 operator \u003e\u003e (istream\u0026 is, MyClass\u0026 a);","index":2,"selected":false},{"title":"istream\u0026 operator \u003e\u003e (istream\u0026 is, MyClass a);","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_23.png","parse":"本题考查重载流运算符“\u003e\u003e”，根据重载规则，本题答案为A。"},{"title":"下列关于基类和派生类关系的叙述中，正确的是（）。","chooseList":[{"title":"每个类最多只能有一个直接基类","index":0,"selected":false},{"title":"派生类中的成员可以访问基类中的任何成员","index":1,"selected":false},{"title":"基类的构造函数必须在派生类的构造函数体中调用","index":2,"selected":false},{"title":"派生类除了继承基类的成员，还可以定义新的成员","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查派生类与基类的关系，派生类可以有多个直接基类，而派生类有三种继承方式，在私有继承中，派生类的成员并不能访问基类的成员。如果基类中定义了缺省构造函数或根本没有定义任何一个构造函数时，在派生类构造函数的定义中可以省略对基类构造函数的调用。故选D。"},{"title":"有如下类声明：[image]下列关于getValue成员函数的定义中，正确的是（）。","chooseList":[{"title":"SAMPLE::setVaule(int n0) { n \u003d n0; }","index":0,"selected":false},{"title":"void SAMPLE::setValue(int n0) { n \u003d n0; }","index":1,"selected":false},{"title":"void setValue(int n0) { n \u003d n0; }","index":2,"selected":false},{"title":"setValue(int n0) { n \u003d n0; }","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_33.png","parse":"本题考查在类外定义类的成员函数，需要使用作用域限定符“::”，属于基础知识。故选B。"},{"title":"模板对类型的参数化提供了很好的支持，因此（）。","chooseList":[{"title":"类模板的主要作用是生成抽象类","index":0,"selected":false},{"title":"类模板中的成员函数都没有返回值","index":1,"selected":false},{"title":"在类模板中的数据成员都具有同样类型","index":2,"selected":false},{"title":"类模板实例化时，编译器将根据给出的模板实参生成一个类","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查类模板的基本概念。类模板的定义和声明都以关键字template开头。关键字后面是一个用逗号分隔的模板参数表，用尖括号“\u003c\u003e”括起来，这个表被称为类模板的模板参数表。类模板是类的抽象，类是类模板的实例。类模板使类中的一些数据成员和成员函数的参数或返回值可以取任意的数据类型。故选D。"},{"title":"程序流程图中带有箭头的线段表示的是（）。","chooseList":[{"title":"控制流","index":0,"selected":false},{"title":"数据流","index":1,"selected":false},{"title":"调用关系","index":2,"selected":false},{"title":"图元关系","index":3,"selected":false}],"mode":0,"answer":0,"parse":"在数据流图中，用标有名字的箭头表示数据流。在程序流程图中，用标有名字的箭头表示控制流。故选A。"},{"title":"对长度为n的线性表排序，在最坏情况下，比较次数不是n(n-1)/2的排序方法是（）。","chooseList":[{"title":"堆排序","index":0,"selected":false},{"title":"快速排序","index":1,"selected":false},{"title":"冒泡排序","index":2,"selected":false},{"title":"直接插入排序","index":3,"selected":false}],"mode":0,"answer":0,"parse":"除了推排序算法的比较次数是O(nlog2n)，其他的都是n(n-1)/2。故选A。"},{"title":"下列语句中，错误的是（）。","chooseList":[{"title":"const int buffer \u003d 256;","index":0,"selected":false},{"title":"const int temp;","index":1,"selected":false},{"title":"const double *point;","index":2,"selected":false},{"title":"const double *rt \u003d new double(5.5);","index":3,"selected":false}],"mode":0,"answer":1,"parse":"const是C++的一个关键字，它限定一个变量不允许被改变。使用const在一定程度上可以提高程序的安全性和可靠性。限定符声明变量只能被读取，因此必须初始化。B选项中没有初始化，B错误。C选项为指向常量的指针，定义时初始化与否均可，如果是const *double point形式，则为常指针，必须在定义时进行初始化，A、C、D均正确。"},{"title":"下列关于C++函数的说明中，正确的是（）。","chooseList":[{"title":"内联函数就是定义在另一个函数体内部的函数","index":0,"selected":false},{"title":"函数体的最后一条语句必须是return语句","index":1,"selected":false},{"title":"标准C++要求在调用一个函数前必须先声明其原型","index":2,"selected":false},{"title":"编译器会根据函数的返回值和参数表来区分函数的不同重载形式","index":3,"selected":false}],"mode":0,"answer":3,"parse":"一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中。而内联函数在调用时，是将调用表达式用内联函数体来替换，而不是在定义在另一个函数体内，A错误；函数可以没有返回值，所以就不需要return了，B错误；如果被调函数在调用之前已经定义，则不需要声明函数原型，C错误；故选D"},{"title":"下面是重载为非成员函数的运算符的函数原型，其中错误的是（）。","chooseList":[{"title":"Fraction operation+(Fraction, Fraction);","index":0,"selected":false},{"title":"Fraction operation-(Fraction);","index":1,"selected":false},{"title":"Fraction\u0026 operation\u003d(Fraction\u0026, Fraction);","index":2,"selected":false},{"title":"Fraction\u0026 operation+\u003d(Fraction\u0026, Fraction);","index":3,"selected":false}],"mode":0,"answer":2,"parse":"本题考查四种运算符作为非成员函数的重载的使用方法，根据重载规则（请查阅本卷前面的解析），本题答案为C。"},{"title":"下列关于虚函数的说明中，正确的是（）。","chooseList":[{"title":"虚函数不得是静态成员函数","index":0,"selected":false},{"title":"只能通过指针域或引用调用虚函数","index":1,"selected":false},{"title":"从虚基类继承的函数都是虚函数","index":2,"selected":false},{"title":"抽象类中的成员函数都是虚函数","index":3,"selected":false}],"mode":0,"answer":0,"parse":"在某基类中声明为virtual并在一个或多个派生类中被重新定义的成员函数。虚函数必须是基类的非静态成员函数，其访问权限可以是protected或public。如果一个类包含了纯虚函数，称此类为抽象类。故选A。"},{"title":"有如下类定义：[image]在标注号码的行中，能被正确编译的是（）。","chooseList":[{"title":"1","index":0,"selected":false},{"title":"2","index":1,"selected":false},{"title":"3","index":2,"selected":false},{"title":"4","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_32.png","parse":"只能通过构造函数的参数初始化列表对常数据成员进行初始化，本题中常数据成员为c。1通过默认构造函数初始化c，A错误。常成员函数只能引用本类中数据成员，而不能修改它，2错误，即B错误。静态成员函数由于没有this指针，所以不能访问本类中的非静态成员，3（C）错误。故选D。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"Base\nBase\n","index":0,"selected":false},{"title":"Base\nDerived\n","index":1,"selected":false},{"title":"Derived\nBase\n","index":2,"selected":false},{"title":"Derived\nDerived\n","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test1_37.png","parse":"在某基类中声明为“virtual”并在一个或多个派生类中被重新定义的成员函数，本题中定义了一个派生类对象obj，执行f函数后，将派生类对象obj转化为基类对象，由于fun1不是虚函数，所以输出基类的fun1；而fun2是虚函数，所以输出派生类的fun2。故选B。"}]}