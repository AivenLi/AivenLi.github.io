{"code":0,"msg":"success","data":[{"title":"一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（）。","chooseList":[{"title":"12345ABCDE","index":0,"selected":false},{"title":"EDCBA54321","index":1,"selected":false},{"title":"ABCDE12345","index":2,"selected":false},{"title":"54321EDCBA","index":3,"selected":false}],"mode":0,"answer":1,"parse":"栈是先进后出的原则组织数据，所以入栈最早的最后出栈，故选B。"},{"title":"在软件开发中，需求分析阶段可以使用的工具是（）。","chooseList":[{"title":"N-S图","index":0,"selected":false},{"title":"DFD图","index":1,"selected":false},{"title":"PAD图","index":2,"selected":false},{"title":"程序流程图","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在需求分析阶段可以使用的工具有数据流图DFD图，数据字典DD，判定树与判定表，故选B。"},{"title":"下列语句中，错误的是（）。","chooseList":[{"title":"const int buffer\u003d256;","index":0,"selected":false},{"title":"const double *point;","index":1,"selected":false},{"title":"int const buffer\u003d256;","index":2,"selected":false},{"title":"double * const point;","index":3,"selected":false}],"mode":0,"answer":3,"parse":"const是C++的一个关键字，用于限定不允许改变的变量。选项B是指向常量的指针，定义时可以不初始化；选项D是指针常量，定义时必须初始化。故选D。"},{"title":"为了取代C中带参数的宏，在C++中使用（）。","chooseList":[{"title":"重载函数","index":0,"selected":false},{"title":"内联函数","index":1,"selected":false},{"title":"递归函数","index":2,"selected":false},{"title":"友元函数","index":3,"selected":false}],"mode":0,"answer":1,"parse":"一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内敛函数在调用时，是将调用表达式用内敛函数体来替换，即类似于宏。故选B。"},{"title":"关于运算符重载，下列表述中正确的是（）。","chooseList":[{"title":"C++已有的任何运算符都可以重载","index":0,"selected":false},{"title":"运算符函数的返回类型不能声明为基本数据类型","index":1,"selected":false},{"title":"在类型转换符函数的定义中不需要声明返回类型","index":2,"selected":false},{"title":"可以通过运算符重载来创建C++中原来没有的运算符","index":3,"selected":false}],"mode":0,"answer":2,"parse":"重载运算符的规则如下：\n(1). C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载；\n(2). C++不能重载的运算符只有5个；\n(3). 重载不能改变运算符运算对象的个数；\n(4). 重载不能改变运算符的优先级和结合性；\n(5). 重载运算符的函数不能有默认的参数；\n(6). 重载的运算符必须和用户定义的自定义类型的对象一起使用，至少应有一个是类对象，即不允许参数全部是C++的标准类型。故选C。"},{"title":"下列有关继承和派生的叙述中，正确的是（）。","chooseList":[{"title":"如果一个派生类公有继承其基类，则该派生类对象可以访问基类的保护成员","index":0,"selected":false},{"title":"派生类的成员函数可以访问基类的所有成员","index":1,"selected":false},{"title":"基类对象可以赋值给派生类对象","index":2,"selected":false},{"title":"如果派生类没有实现基类的一个纯虚函数，则派生类是一个抽象类","index":3,"selected":false}],"mode":0,"answer":3,"parse":"私有继承方式为基类的公用成员和保护成员在派生类中成了私有成员，其私有成员仍为基类私有，但派生类对象可以访问基类的保护成员，所以基类对象不能赋值给派生类对象。抽象类是指含有纯虚函数的类，故选D。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"232","index":0,"selected":false},{"title":"231","index":1,"selected":false},{"title":"222","index":2,"selected":false},{"title":"221","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_31.png","parse":"本题考查构造函数和析构函数的调用顺序，调用顺序为先构造的后析构，后构造的先析构。本题中定义了一个对象ob1，会执行构造函数，那么i就变成了1；再执行函数f后，由于又定义了一个对象ob2，所以再次执行构造函数，i就变为了2，输出了2。函数执行完后执行析构函数，i变为了1，然后又定义了对象指针ob3，i变为了2。释放ob3后i变成了1。故选D。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"B1B2","index":0,"selected":false},{"title":"A1A2","index":1,"selected":false},{"title":"B1A2","index":2,"selected":false},{"title":"A1B2","index":3,"selected":false}],"mode":0,"answer":2,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_36.png","parse":"本题考查虚函数。虚函数指在基类中声明为virtual并在一个或多个派生类中被重新定义的成员函数。题中定义了一个派生类对象B，并使用类A的对象指针指向B，由于基类A中的func1为虚函数，所以会执行派生类的func1，输出B1，而基类中的func2不是虚函数，所以p-\u003efunc2()会执行基类的func2，输出A2。故选C。"},{"title":"在长度为n的有序线性表中进行二分查找，最坏情况下需要比较的次数是（）。","chooseList":[{"title":"O(n)","index":0,"selected":false},{"title":"O(n^2)","index":1,"selected":false},{"title":"O(log2n)","index":2,"selected":false},{"title":"O(nlog2n)","index":3,"selected":false}],"mode":0,"answer":2,"parse":"当有序线性表为顺序存储时才能用二分法查找。可以证明的是对于长度为n的有序线性表，在最坏情况下，二分法查找只需要比较log2n次，而顺序查找需要比较n次。"},{"title":"一间宿舍可住多个学生，则实体宿舍和学生之间的联系是（）。","chooseList":[{"title":"一对一","index":0,"selected":false},{"title":"一对多","index":1,"selected":false},{"title":"多对一","index":2,"selected":false},{"title":"多对多","index":3,"selected":false}],"mode":0,"answer":1,"parse":"一间宿舍可以住多个学生，但一个学生只能住一间宿舍，所以实体宿舍和学生之间是一对多的关系。故选B。"},{"title":"有如下说明：\nint a [10] \u003d {1,2,3,4,5,6,7,8,9,10}, *p\u003da;\n则数值为9的表达式是（）。","chooseList":[{"title":"*p+9","index":0,"selected":false},{"title":"*(p+8)","index":1,"selected":false},{"title":"*p+\u003d9","index":2,"selected":false},{"title":"p+8","index":3,"selected":false}],"mode":0,"answer":1,"parse":"本题考查指向数组的指针，本题中指针变量p指向数组a，那么*p的值就是1，即表示数组的第一个元素，那么数值为9的表达式就是将指针向后移动8个地址，即P+8指向的是数组元素值为9，所以数值为9的表达式是*(p+8)。故选B。"},{"title":"在函数中，可以用auto、extern、register和static这四个关键字中的一个来说明变量的存储类型，如果不说明存储类型，则默认的存储类型是（）。","chooseList":[{"title":"auto","index":0,"selected":false},{"title":"extern","index":1,"selected":false},{"title":"register","index":2,"selected":false},{"title":"static","index":3,"selected":false}],"mode":0,"answer":0,"parse":"变量的存储方法分为静态存储和动态存储两大类，包含4种：auto、static、register和extern。变量如果没有说明存储类型，那么默认是auto。故选A。"},{"title":"下列情况中，不会调用拷贝构造函数的是（）。","chooseList":[{"title":"用一个对象去初始化同一类的另一个新对象时","index":0,"selected":false},{"title":"将类的一个对象赋值给该类的另一个对象时","index":1,"selected":false},{"title":"函数的形参是类的对象，调用函数进行形参和实参结合时","index":2,"selected":false},{"title":"函数的返回值是类的对象，函数执行返回调用时","index":3,"selected":false}],"mode":0,"answer":1,"parse":"本题考查复制构造函数，复制构造函数在以下3种情况使用：\n1. 程序中需要新建立一个对象，并用另一个对象对它初始化；\n2. 函数的参数为类的对象；\n3. 函数的返回值是类的对象。\n其中B选项是由赋值运算符重载实现的。故选B。"},{"title":"有如下程序：[image]已知其执行后的输出结果为：\nBase::fun\nDerived::fun\n则程序中【】处应填入的语句是（）。","chooseList":[{"title":"Base.fun();","index":0,"selected":false},{"title":"Base::fun();","index":1,"selected":false},{"title":"Base-\u003efun();","index":2,"selected":false},{"title":"fun();","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_28.png","parse":"本题考查公用继承对基类成员的访问属性。在公用继承中，基类的公用成员和保护成员在派生类保持原有的访问属性，其私有成员仍为基类私有。本题中想要输出Base::fun，则必须调用基类的公用成员函数fun，所以使用Base::fun();来调用基类的成员函数fun。故选B。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"B","index":0,"selected":false},{"title":"BA","index":1,"selected":false},{"title":"AB","index":2,"selected":false},{"title":"BB","index":3,"selected":false}],"mode":0,"answer":2,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_33.png","parse":"本题考查派生类的构造函数和析构函数，在定义一个派生类的对象时，先调用基类的构造函数，然后再执行派生类的构造函数；对象释放时，先执行派生类的析构函数，再执行基类的析构函数。本题中定义了一个派生类对象d1，首先执行基类的构造函数，输出A；然后执行派生类的构造函数，输出B。故选C。"},{"title":"关于关键字class和typename，下列表示中正确的是（）。","chooseList":[{"title":"程序中的typename都可以替换为class","index":0,"selected":false},{"title":"程序中的class都可以替换为typename","index":1,"selected":false},{"title":"在模板形参表中只能用typename来声明参数的类型","index":2,"selected":false},{"title":"在模板形参表中只能用class或typename来声明参数的类型","index":3,"selected":false}],"mode":0,"answer":0,"parse":"程序中的typename都可以替换为class，但程序中的class不可以全部替换为typename。在模板类型形参中除了typename和class以外，也可以用常规类型来声明参数的类型。故选A。"},{"title":"数据流图中带有箭头的线段表示的是（）。","chooseList":[{"title":"控制流","index":0,"selected":false},{"title":"事件驱动","index":1,"selected":false},{"title":"模块调用","index":2,"selected":false},{"title":"数据流","index":3,"selected":false}],"mode":0,"answer":3,"parse":"数据流图中带有箭头的线段表示的是数据流，即沿箭头方向传送数据的通道，一般在旁边标注数据流名，故选D。"},{"title":"有三个关系R、S和T如下：[image]由关系R和S通过运算得到关系T，则所使用的运算为（）。","chooseList":[{"title":"交","index":0,"selected":false},{"title":"并","index":1,"selected":false},{"title":"笛卡尔积","index":2,"selected":false},{"title":"自然连接","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_10.png","parse":"自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉，所以根据T关系中的有序组可知R与S进行的是自然连接操作。故选D。"},{"title":"下列字符串中，不可以用做C++标识符的是（）。","chooseList":[{"title":"y_2006","index":0,"selected":false},{"title":"_TEST_H","index":1,"selected":false},{"title":"Return","index":2,"selected":false},{"title":"switch","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查C++标识符命名规则，其规则有如下几点：\n(1). 所有标识符必须由字母、数字或下划线组成，且必须由字母或下划线开头；\n(2). 所有标识符不能使用C++已有的关键字；\n(3). 大、小写字母表示不同意义，即代表不同的标识符。选项C中虽然return是关键字，但因首字母大、小写不同，也可用于标识符，但不建议使用。故选D。"},{"title":"若有下面的函数调用：\nfun(a+b, 3, max(n-1, b))\n则fun的实参个数是（）。","chooseList":[{"title":"3","index":0,"selected":false},{"title":"4","index":1,"selected":false},{"title":"5","index":2,"selected":false},{"title":"6","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查函数实参个数的基础知识，根据实参的概念，(a+b)、3、max(n-1, b)分别为其中的3个实参。故选A。"},{"title":"由于常对象不能被更新，因此（）。","chooseList":[{"title":"通过常对象只能调用它的常成员函数","index":0,"selected":false},{"title":"通过常对象只能调用静态成员函数","index":1,"selected":false},{"title":"常对象的成员都是常成员","index":2,"selected":false},{"title":"通过常对象可以调用任何不改变对象值","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查常对象的基本知识，常对象只能调用它的常成员函数，而不能调用非const函数，常对象的成员函数不一定都是常成员函数，只需要保证其数据成员是常数据成员即可。故选A。"},{"title":"有如下程序：[image]若程序的输出结果是：\n123\n则程序中【】处遗漏的语句是（）。","chooseList":[{"title":"cout \u003c\u003c fun1.value() \u003c\u003c Fun::i \u003c\u003c fun2.value();","index":0,"selected":false},{"title":"cout \u003c\u003c Fun::i \u003c\u003c fun1.value() \u003c\u003c fun2.value();","index":1,"selected":false},{"title":"cout \u003c\u003c fun1.value() \u003c\u003c fun2.value() \u003c\u003c Fun::i;","index":2,"selected":false},{"title":"cout \u003c\u003c fun2.value() \u003c\u003c Fun::i \u003c\u003c fun1.value();","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_30.png","parse":"本题考查构造函数、常成员函数和静态数据成员。外部同名的变量赋值，不能改变类的静态变量值，所以Fun对象里的i值为2，故选A。"},{"title":"有如下程序：[image]下列叙述中正确的是（）。","chooseList":[{"title":"语句“Instrument *p \u003d 0;”编译时出错","index":0,"selected":false},{"title":"语句“Instrument s;”编译时出错","index":1,"selected":false},{"title":"类Piano中的Display函数不是虚函数","index":2,"selected":false},{"title":"类Instrument是一个虚基类","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_35.png","parse":"本题考查纯虚函数和抽象类，纯虚函数是在声明虚函数时被“初始化”为0的函数，包含纯虚函数的类为抽象类，抽象类不能被实例化，所以语句“Instrument s;”在编译时出错。故选B。"},{"title":"下列关于C++流的描述中，错误的是（）。","chooseList":[{"title":"cout \u003e\u003e \u0027A\u0027表达式可输出字符A","index":0,"selected":false},{"title":"eof()函数可以检测是否到达文件尾","index":1,"selected":false},{"title":"对磁盘文件进行流操作时，必须包含头文件fstream","index":2,"selected":false},{"title":"以ios_base::out模式打开的文件不存在时，将自动建立一个新文件","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查C++流，想要输出字符“A”，则应是cout \u003c\u003c \"A\"，故选A。"},{"title":"下列叙述中正确的是（）。","chooseList":[{"title":"循环队列中元素的个数是由队头和队尾共同决定","index":0,"selected":false},{"title":"循环队列有队头和队尾两个指针，因此，循环队列是非线性结构","index":1,"selected":false},{"title":"在循环队列中，只需要队头指针就能反映队列中元素的动态变化情况","index":2,"selected":false},{"title":"在循环队列中，只需要队尾指针就能反映队列中元素的动态变化情况","index":3,"selected":false}],"mode":0,"answer":0,"parse":"循环队列有队头和队尾两个指针，但是循环队列仍是线性结构的，所以B错误；在循环队列中只需要队头与队尾两个指针共同反映队列中元素的动态变化情况，所以C和D均错误。"},{"title":"在面向对象方法中，不属于“对象”基本特点的是（）。","chooseList":[{"title":"一致性","index":0,"selected":false},{"title":"分类性","index":1,"selected":false},{"title":"多态性","index":2,"selected":false},{"title":"标识唯一性","index":3,"selected":false}],"mode":0,"answer":0,"parse":"对象有如下一些基本特点：表示唯一性、分类性、多态性、封装性、模块独立性好。故选A。"},{"title":"if语句的语法格式可描述为：\n格式1：if(\u003c条件\u003e)\u003c语句\u003e\n或\n格式2：if(\u003c条件\u003e)\u003c语句1\u003e\nelse\u003c语句2\u003e\n关于上面的语法格式，下拉表述中错误的是（）。","chooseList":[{"title":"\u003c条件\u003e部分可以是一个if语句，例如if((if(a\u003d\u003d0)...)...","index":0,"selected":false},{"title":"\u003c语句\u003e部分可以是一个if语句，例如if(...)if(...)...","index":1,"selected":false},{"title":"如果在\u003c条件\u003e前加上逻辑非运算符!并交换\u003c语句1\u003e和\u003c语句2\u003e的位置，语句功能不变","index":2,"selected":false},{"title":"\u003c语句\u003e部分可以是一个循环语句，例如if(...)while(...)...","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查if语句，if语句的条件部分不能嵌套if语句，A错误，故选A。"},{"title":"通过运算符重载，可以改变运算符原有的（）。","chooseList":[{"title":"操作数类型","index":0,"selected":false},{"title":"操作数个数","index":1,"selected":false},{"title":"优先级","index":2,"selected":false},{"title":"结核性","index":3,"selected":false}],"mode":0,"answer":0,"parse":"重载运算符的规则如下：\n(1). C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载；\n(2). C++不能重载的运算符只有5个；\n(3). 重载不能改变运算符运算对象的个数；\n(4). 重载不能改变运算符的优先级和结合性；\n(5). 重载运算符的函数不能有默认的参数；\n(6). 重载的运算符必须和用户定义的自定义类型的对象一起使用，至少应有一个是类对象，即不允许参数全部是C++的标准类型。故选A。"},{"title":"有如下程序：[image]编译运行这个程序将出现的情况是（）。","chooseList":[{"title":"编译出错，无法运行","index":0,"selected":false},{"title":"3","index":1,"selected":false},{"title":"3.0","index":2,"selected":false},{"title":"输出一个不确定的数","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_22.png","parse":"本题考查函数调用及传值方式传递参数，执行函数function时，并没有将数值3传回来，而val又没有初始化，所以会输出一个不确定的值，D选项正确。"},{"title":"在公有继承的情况下，允许派生类直接访问的基类成员包括（）。","chooseList":[{"title":"公有成员","index":0,"selected":false},{"title":"公有成员和保护成员","index":1,"selected":false},{"title":"公有成员、保护成员和私有成员","index":2,"selected":false},{"title":"保护成员","index":3,"selected":false}],"mode":0,"answer":1,"parse":"本题考查公用继承对基类成员的访问属性。在公用继承中，基类的公用成员和保护成员在派生类中保持原有的访问属性，其私有成员仍为基类私有。故选B。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"33","index":0,"selected":false},{"title":"38","index":1,"selected":false},{"title":"83","index":2,"selected":false},{"title":"88","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_32.png","parse":"本题考查常对象、常成员函数及构造函数。常对象只能调用常成员函数，所以本题中，对象a为普通对象，执行a.get()后，会执行默认构造函数，输出3；对象b为常对象，执行b.get()后，会执行常构造函数，输出8。故选B。"},{"title":"关于在调用模板函数时模板实参的使用，下列表述中正确的是（）。","chooseList":[{"title":"对于虚拟类型参数所对应的模板实参，如果能从模板函数的实参中获得相同的信息，则都可以省略","index":0,"selected":false},{"title":"对于虚拟类型参数所对应的模板实参，如果它们是参数表中的最后的若干个参数，则都可以省略","index":1,"selected":false},{"title":"对于虚拟类型参数所对应的模板实参，若能够省略则必须省略","index":2,"selected":false},{"title":"对于常规参数所对应的模板实参，任何情况下都不能省略","index":3,"selected":false}],"mode":0,"answer":0,"parse":"在调用一个模板函数时，编译系统需要足够的信息来判别每个虚拟类型参数所对应的实际类型，可以从两个不同的渠道获得这样的信息：从模板实参表（用“\u003c\u003e”括起来的参数表）或从模板函数实参表（用“()”括起来的参数表）。如果从后者获得的信息已经能够判定其中部分或全部虚拟类型参数所对应的实际参数，而且它们又正好是参数表中最后的若干参数，则模板实参表中的那几个参数可以省略。如果模板实参表中的实参都被省略了，则空表“\u003c\u003e”也可以不要，因此D错误。反之，对于某个模板实参，如果从模板函数的实参表中无法获得同样的信息，就不能省略；或者虽然能够获得同样的信息，但在它后面还有其他不能省略的实参，则其自身还是不能省略。故选A。"},{"title":"下列叙述中正确的是（）。","chooseList":[{"title":"链式存储结构比顺序存储结构节省存储空间","index":0,"selected":false},{"title":"顺序存储结构能存储有序表，链式存储结构不能存储有序表","index":1,"selected":false},{"title":"顺序存储结构只针对线性结构，链式存储结构只针对非线性结构","index":2,"selected":false},{"title":"顺序存储结构的存储一定是连续的，链式存储结构的存储空间不一定是连续的","index":3,"selected":false}],"mode":0,"answer":3,"parse":"链式存储结构既可以针对线性结构也可以针对非线性结构，所以B、C均错误。链式存储结构中每个结点都由数据域与指针域两部分组成，增加了存储空间，A错误。"},{"title":"在数据管理技术发展的三个阶段中，数据共享最好的是（）。","chooseList":[{"title":"人工管理阶段","index":0,"selected":false},{"title":"文件系统阶段","index":1,"selected":false},{"title":"数据库系统阶段","index":2,"selected":false},{"title":"三个阶段相同","index":3,"selected":false}],"mode":0,"answer":2,"parse":"数据管理发展至今已经历了三个阶段：人工管理阶段、文件系统阶段和数据库系统阶段。其中最后一个阶段结构简单，使用方便逻辑性强物理性少，在各方面的表现都最好，一直占据数据库领域的主导地位，故选C。"},{"title":"有如下程序段：\nint i \u003d 0, j \u003d 1;\nint \u0026r \u003d i; // (1)\nr \u003d j; // (2)\nint *p \u003d \u0026i; // (3)\n*p \u003d \u0026r; // (4)\n其中会产生编译错误的语句是（）。","chooseList":[{"title":"(1)","index":0,"selected":false},{"title":"(2)","index":1,"selected":false},{"title":"(3)","index":2,"selected":false},{"title":"(4)","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查指针和引用，(1)为引用，正确；(4)中\u0026r表示一个地址，而*p已经是一个值了，不能将一个指针赋值给一个值，所以编译错误。故选D。"},{"title":"下列运算符函数中肯定不属于类FunNumber的成员函数的是（）。","chooseList":[{"title":"int operator-(FunNumber);","index":0,"selected":false},{"title":"FunNumber operator-();","index":1,"selected":false},{"title":"FunNumber operator-(int);","index":2,"selected":false},{"title":"int operator-(FunNumber, FunNumber);","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题考查运算符重载的一些规则：\n1. 一般情况下，单目运算符最好重载为类的成员函数，双目运算符则最好重载为类的友元函数；\n2. 双目运算符\u003d、()、[]和-\u003e不能重载为类的友元函数；\n3. 类型转换函数只能定义为一个类的成员函数，而不能定义为类的友元函数；\n4. 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好；\n5. 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数；\n6. 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）；如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。故选D。"},{"title":"以下关键字不能用来声明类的访问权限的是（）。","chooseList":[{"title":"public","index":0,"selected":false},{"title":"static","index":1,"selected":false},{"title":"protected","index":2,"selected":false},{"title":"private","index":3,"selected":false}],"mode":0,"answer":1,"parse":"类的成员访问权限有3种：\npublic 公用\nprotected 保护\nprivate 私有\n故选B。"},{"title":"有如下程序：[image]执行这个程序的输出结果是（）。","chooseList":[{"title":"ABX","index":0,"selected":false},{"title":"ABXB","index":1,"selected":false},{"title":"AXB","index":2,"selected":false},{"title":"AXBB","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_29.png","parse":"构造函数和析构函数的调用顺序为先构造的后析构，后构造的先析构。故选D。"},{"title":"有如下类定义：[image]编译时发现有一处语法错误，对这个错误最准确的描述是（）。","chooseList":[{"title":"函数getK试图访问基类的私有成员变量k","index":0,"selected":false},{"title":"在类MyDerived的定义中，基类名MyBase前缺少关键字public、protected或private","index":1,"selected":false},{"title":"类MyDerived缺少一个无参的构造函数","index":2,"selected":false},{"title":"类MyDerived的构造函数没有对基类数据成员k进行初始化","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test2_34.png","parse":"默认继承方式为私有继承，私有继承将基类的公用成员和保护成员都变为了私有成员，基类的私有成员依然属于基类私有，派生类不能访问基类的私有成员。故选A。"},{"title":"在下列枚举符号中，用来表示“相对于当前位置”文件定位方式的是（）。","chooseList":[{"title":"ios_base::cur","index":0,"selected":false},{"title":"ios_base::beg","index":1,"selected":false},{"title":"ios_base::out","index":2,"selected":false},{"title":"ios_base::end","index":3,"selected":false}],"mode":0,"answer":0,"parse":"streamoff定义于iostream.h中，定义有偏移量offset所能取得的最大值，seek_dir表示移动的基准位置，是一个有以下值的枚举：\nios::beg 文件开头\nios::cur 文件当前位置\nios::end 文件结尾\n故选A。"}]}