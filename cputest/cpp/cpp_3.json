{"code":0,"msg":"success","data":[{"title":"数据流图（DFD）中的有向箭头（→）表示______。","chooseList":[{"title":"数据流","index":0,"selected":false},{"title":"控制流","index":1,"selected":false},{"title":"输入流","index":2,"selected":false},{"title":"输出流","index":3,"selected":false}],"mode":0,"answer":0,"parse":"数据流图：简称DFD,就是采用图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。数据流图的基本符号的意思：\n1、矩形表示数据的外部实体；\n2、圆角的矩形表示变换数据的处理逻辑；\n3、双杠(带一边开口，一边闭合)，表示数据存储；\n4、箭头表示数据流。\n故选A。"},{"title":"软件系统总体结构图的作用是（）。","chooseList":[{"title":"描述软件系统结构的图形工具","index":0,"selected":false},{"title":"描述软件系统的控制流","index":1,"selected":false},{"title":"描述软件系统的数据流","index":2,"selected":false},{"title":"描述软件系统的数据结构","index":3,"selected":false}],"mode":0,"answer":0,"parse":"软件系统总结结构图是用图形方式描述软件的整体结构，直观的反映各个模块间关系。流程图用于描述系统数据流。数据结构是编码中的定义。"},{"title":"已知下列语句中的x和y都是int型变量，其中错误的语句是（）。","chooseList":[{"title":"x\u003dy++;","index":0,"selected":false},{"title":"x\u003d++y;","index":1,"selected":false},{"title":"(x+y)++;","index":2,"selected":false},{"title":"++x\u003dy;","index":3,"selected":false}],"mode":0,"answer":2,"parse":"对于++、--这样的运算，其操作数必须为一变量，因为x+y是表达式故答案C是错误的。"},{"title":"已知程序中已经定义了函数test，其原型是int test(int,int,int);，则下列重载形式中正确的是（）。","chooseList":[{"title":"char test(int,int,int);","index":0,"selected":false},{"title":"double test(int,int,double);","index":1,"selected":false},{"title":"int test(int,int,int\u003d0);","index":2,"selected":false},{"title":"float test(int,int,float\u003d3.5F);","index":3,"selected":false}],"mode":0,"answer":1,"parse":"在对函数进行重载时，不允许为其指定缺省参数，故C、D是错的，同时，对于重载的函数原型间不允许有类型完全相同的参数列表，故A是错的，对于返回类型，在重载时没有特别的要求。"},{"title":"有如下程序：[image]程序执行时，MyClass类的拷贝构造函数被调用的次数是（）。","chooseList":[{"title":"5","index":0,"selected":false},{"title":"4","index":1,"selected":false},{"title":"3","index":2,"selected":false},{"title":"2","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_23.png","parse":"obj1(10)将执行一次构造函数，obj2(0)也将执行一次构造函数；\nobj3(obj1)将以obj1作为参数执行一次构造函数；\nfun(obj3)中的temp(p)也将执行一次构造函数，而fun本身是按值传递参数的，形参在fun函数内也要分配独立的空间，故也要执行一次构造函数，对于其返回结果也是MyClass类型的，同样需要执行一次构造函数，故一共要执行4次。"},{"title":"在下面的运算符重载函数的原型中，错误的是（）。","chooseList":[{"title":"Volume operator-(double,double);","index":0,"selected":false},{"title":"double Volume::operator-(double);","index":1,"selected":false},{"title":"Volume Volume::operator-(Volume);","index":2,"selected":false},{"title":"Volume operator-(Volume,Volume);","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题主要考查了运算符的重载。对于运算符的重载，通常有两种形式。\n1、操作结果 operator 运算符(操作数1,[操作数2])\n2、操作结果 类::operator 运算符(操作数)\n对于上述选项中，B、C为第二种类型，A、D为第一种类型，在第一种类型中，两个操作数必须至少有一个自定义类，对选项A而言，其两个操作数均为double型数据，因此选项A是错误的运算符重载。故选为A。"},{"title":"有以下程序：[image]程序执行后的输出结果是（）。","chooseList":[{"title":"6+6i","index":0,"selected":false},{"title":"6+1i","index":1,"selected":false},{"title":"1+6i","index":2,"selected":false},{"title":"1+1i","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_33.png","parse":"本题定义了一个复数类，并在该类上重载了+运算符。在main函数中，定义了一个复数类a，其值为两个复数1+i与5的和。在复数类中，定义了real与imag方法，分别用来取出复数的实部与虚部。"},{"title":"下列关于函数模板的描述中，正确的是（）。","chooseList":[{"title":"函数模板是一个实例函数","index":0,"selected":false},{"title":"使用函数模板定义的函数没有返回类型","index":1,"selected":false},{"title":"函数模板的类型参数与函数的参数相同","index":2,"selected":false},{"title":"通过使用不同的类型参数，可以从函数模板得到不同的实例函数","index":3,"selected":false}],"mode":0,"answer":3,"parse":"函数模板是一系列相关函数的模型或样板，这些函数的源代码形式相同，只是所针对的数据类型不同。对于函数模板，数据类型本身成了它的参数，因而是一种参数化类型的函数。因此选项A错误。声明一个函数模板的格式是：template \u003c模板形参表声明\u003e \u003c函数声明\u003e，其中的模板形参表声明是由一个或多个模板形参组成（如果是多个，需要用逗号隔开）。每个模板形参具有下面几种形式：\n（1）typename 参数名，\n（2）class 参数名，\n（3）类型修饰 参数名，\n与函数的参数不同，因此选项C错误。格式中的\u003c函数声明\u003e与一般函数的声明类似，只是某些类型修饰符被虚拟类型参数所替代，因此使用函数模板定义的函数可以有返回类型，故选项B错误。在调用一个模板函数时，编译系统需要足够的信息来判别每个虚拟类型参数所对应的实际类型，通过使用不同的类型参数，可以从函数模板得到不同的实例函数，因此选项D正确。"},{"title":"下面不属于结构化程序设计原则的是（）。","chooseList":[{"title":"模块化","index":0,"selected":false},{"title":"自顶向下","index":1,"selected":false},{"title":"可继承性","index":2,"selected":false},{"title":"逐步求精","index":3,"selected":false}],"mode":0,"answer":2,"parse":"结构化程序设计原则包括：自顶向下，逐步求精，模块化，限制使用goto语句。"},{"title":"对软件系统总体结构图，下面描述中错误的是（）。","chooseList":[{"title":"深度等于控制的层数","index":0,"selected":false},{"title":"扇入是一个模块直接调用的其他模块数","index":1,"selected":false},{"title":"扇出是一个模块直接调用的其他模块数","index":2,"selected":false},{"title":"原子模块一定是结构图中位于叶子节点的模块","index":3,"selected":false}],"mode":0,"answer":1,"parse":"模块的扇入指模块直接上级模块的个数。模块的扇出指模块的直属下级模块个数。深度是软件的层数。原子模块是不可再进行模块拆分的模块，表现在结构图上即为叶子节点。"},{"title":"下列程序的输出结果是（）。[image]","chooseList":[{"title":"HELLO,WORLD","index":0,"selected":false},{"title":"Hello,World","index":1,"selected":false},{"title":"hELLO,wORLD","index":2,"selected":false},{"title":"hello,world","index":3,"selected":false}],"mode":0,"answer":0,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_15.png","parse":"此程序段的功能是将字符串中的小写字母转换为大写字母并将其输出。"},{"title":"有以下类定义：\nclass MyClass {\npublic:\nMyClass() { cout \u003c\u003c 1; }\n}\n则执行语句MyClass a, b[2], *p[2];后，程序的输出结果是（）。","chooseList":[{"title":"11","index":0,"selected":false},{"title":"111","index":1,"selected":false},{"title":"1111","index":2,"selected":false},{"title":"11111","index":3,"selected":false}],"mode":0,"answer":1,"parse":"class MyClass定义了一个类，其中MyClass(){cout\u003c\u003c1;}为其的构造函数，当程序创建类MyClass的实例时，该函数将会被调用，在执行“MyClass a,b[2],*p[2];”时，一共创建了3个这样的实例，故一共执行构造函数3次，对于变量p，则是声明了一个指针数组，该数组中的元素是指向类MyClass实例的指针，本身并没有创建类的实例。"},{"title":"在C++中用来实现运行时多态性的是（）。","chooseList":[{"title":"重载函数","index":0,"selected":false},{"title":"析构函数","index":1,"selected":false},{"title":"构造函数","index":2,"selected":false},{"title":"虚函数","index":3,"selected":false}],"mode":0,"answer":3,"parse":"构造函数是类在创建实例时自动执行的函数，它不能实现运行时多态；析构函数是类在销毁其实例时创建的，也不能实现运行时多态，重载函数能够使相同的的功能具有统一的接口，但可以有不同的参数。虚函数可以用来动态地根据当前实例所属的类调用相应的函数，实现运行时多态性。"},{"title":"执行语句序列\nofstream outfile(\"DATA.DAT\");\nif(…)cout\u003c\u003c\"OK\";else cout\u003c\u003c\"FAIL\";\n后，如果文件打开成功显示\"OK\"，否则就显示\"FAIL\"。由此可知，上面if语句的…处的表达式应是（）","chooseList":[{"title":"outfile.fail() 或 outfile","index":0,"selected":false},{"title":"outfile.good() 或 !outfile","index":1,"selected":false},{"title":"outfile.good() 或 outfile","index":2,"selected":false},{"title":"outfile.fail() 或 !outfile","index":3,"selected":false}],"mode":0,"answer":2,"parse":"在采用ofstream类打开文件时，在创建其实例时，可在构造函数中输入要打开的文件名，如果打开成功，则返回一个ofstream类的实例，否则创建实例失败，返回0，同时可通过good()或fail()方法来判断文件是否已打开，如果正常打开则fail()方法返回0，good()方法返回非零，否则fail()返回非零，good()返回0。"},{"title":"若AA为一个类，a为该类的非静态数据成员，在该类的一个成员函数定义中访问a时，其书写格式为（）。","chooseList":[{"title":"AA::a","index":0,"selected":false},{"title":"AA.a","index":1,"selected":false},{"title":"a()","index":2,"selected":false},{"title":"AA::a()","index":3,"selected":false}],"mode":0,"answer":0,"parse":"非静态成员函数可以通过数据成员名称直接访问该类的所有非静态数据成员，因此选项A正确。如果成员函数定义了与类作用域内变量同名的另一个变量，那么在函数作用域内，函数作用域内的变量将隐藏类作用域内的变量。要访问这种隐藏变量只须在其前面添加类名和作用域运算符（::），即AA::a。"},{"title":"Windows环境下，由C++源程序文件编译而成的目标文件的扩展名是（）。","chooseList":[{"title":"cpp","index":0,"selected":false},{"title":"exe","index":1,"selected":false},{"title":"obj","index":2,"selected":false},{"title":"lik","index":3,"selected":false}],"mode":0,"answer":2,"parse":"在VC6集成开发环境中，用户可以使用编译（Compile）命令将一个以cpp为扩展名的C++源程序文件转换成一个以obj为扩展名的目标文件。因此选项C正确。"},{"title":"软件的三要素是（）。","chooseList":[{"title":"程序、数据和运行环境","index":0,"selected":false},{"title":"程序、数据和配置","index":1,"selected":false},{"title":"程序、数据和工具","index":2,"selected":false},{"title":"程序、数据及相关文档","index":3,"selected":false}],"mode":0,"answer":3,"parse":"软件三要素包括：程序，数据和文档。"},{"title":"软件编写阶段可进行的软件测试是（）。","chooseList":[{"title":"单元测试","index":0,"selected":false},{"title":"集成测试","index":1,"selected":false},{"title":"确认测试","index":2,"selected":false},{"title":"系统测试","index":3,"selected":false}],"mode":0,"answer":1,"parse":"代码编写阶段可以由开发人员进行单元测试，检测代码编写的各个单元的正确性。"},{"title":"判断字符型变量ch是否为大写英文字母，应使用表达式（）。","chooseList":[{"title":"ch\u003e\u003d\u0027A\u0027\u0026ch\u003c\u003d\u0027Z\u0027","index":0,"selected":false},{"title":"ch\u003c\u003d\u0027A\u0027||ch\u003e\u003d\u0027Z\u0027","index":1,"selected":false},{"title":"\u0027A\u0027\u003c\u003dch\u003c\u003d\u0027Z\u0027","index":2,"selected":false},{"title":"ch\u003e\u003d\u0027A\u0027\u0026\u0026ch\u003c\u003d\u0027Z\u0027","index":3,"selected":false}],"mode":0,"answer":3,"parse":"C++语言提供了三种逻辑运算符，它们是：!（逻辑非）、\u0026\u0026（逻辑与）、||（逻辑或）。其中!为单目运算符，\u0026\u0026和||为双目运算符。本题的选项中符合题意的是D。"},{"title":"下列函数原型声明中错误的是（）。","chooseList":[{"title":"void Fun(int x\u003d0,int y\u003d0);","index":0,"selected":false},{"title":"void Fun(int x,int y);","index":1,"selected":false},{"title":"void Fun(int x,int y\u003d0);","index":2,"selected":false},{"title":"void Fun(int x\u003d0,int y);","index":3,"selected":false}],"mode":0,"answer":3,"parse":"在C++中，可以为参数指定默认值，在函数调用时没有指定与形参相对应的实参时就自动使用默认值。默认参数可以简化复杂函数的调用。默认参数通常在函数名第一次出现在程序中的时候，如在函数原型中，指定默认参数值。指定默认参数的方式从语法上看与变量初始化相似。例如：void myfunc(int x\u003d0,int y\u003d1);如果一个函数中有多个参数，则默认参数应从右至左逐个定义。"},{"title":"关于动态存储分配，下列说法正确的是（）。","chooseList":[{"title":"动态分配的内存空间也可以被初始化","index":0,"selected":false},{"title":"new和delete是C++语言中专门用于动态内存分配和释放的函数","index":1,"selected":false},{"title":"当动态分配内存失败时，系统会立刻崩溃，因此一定要慎用new","index":2,"selected":false},{"title":"当系统内存不够时，会自动回收不再使用的内存单元，因此程序中不必用delete释放内存空间","index":3,"selected":false}],"mode":0,"answer":0,"parse":"new和deleted在C++中用来申请与释放内存的运算，不是函数，故选项B错。动态内存分配时是可以对其进行初始化的，如对类的初始化。在C++中，没有垃圾回收装置，系统本身不会自动回收内存，选项D也错。由于采用了new操作分配内存，在内存分配失败时，产生一个NULL指针，不会导致系统的崩溃，因此建议使用new操作，故选项C错。"},{"title":"在一个类体的下列声明中，正确的纯虚函数声明是（）。","chooseList":[{"title":"virtual void vf()\u003d0;","index":0,"selected":false},{"title":"void vf(int)\u003d0;","index":1,"selected":false},{"title":"virtual int vf(int);","index":2,"selected":false},{"title":"virtual void vf(int){}","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题考查了纯虚函数的定义，在C++中要定义一个函数为虚函数，可在函数定义前加上virtual关键字，如果要定义一个函数为纯虚函数，只要在函数原型后加上\"\u003d0\"就可以了。对于纯虚函数，必须要在其派生类中实现，因此对于一个拥有纯虚函数的类，实质上就是一个抽象类。对于这种类，不能为其创建实例。"},{"title":"有以下类定义：[image]下列类对象定义语句中错误的是（）。","chooseList":[{"title":"MyClass myObj;","index":0,"selected":false},{"title":"MyClass myObj(11,\"13301111155\");","index":1,"selected":false},{"title":"MyClass myObj(12,\u0027m\u0027);","index":2,"selected":false},{"title":"MyClass myObj(12);","index":3,"selected":false}],"mode":0,"answer":1,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_32.png","parse":"对于A，由于在创建MyClass的实例myObj时，没有参数，所以其调用了第一个构造函数。对于B，由于有两个参数，故其调用了第二个构造函数，第二个构造函数有两个缺省参数，在调用时，实参会按从左到右的顺序依次传给形参，所以第二个参数\"13301111155\"会传递给形参ge，而在原型中ge为字符型，实参为指向字符的指针，故在编译时会出现错误。C与D都能够正确的实现参数的传递。"},{"title":"若要对Data类中重载的加法运算符成员函数进行声明，下列选项中正确的是（）。","chooseList":[{"title":"Data +(Data);","index":0,"selected":false},{"title":"Data operator+(Data);","index":1,"selected":false},{"title":"Data +operator(Data);","index":2,"selected":false},{"title":"operator+(Data,Data);","index":3,"selected":false}],"mode":0,"answer":1,"parse":"运算符的重载形式有两种，重载为类的成员函数和重载为类的非成员函数。当运算符重载为类的成员函数时，函数的参数个数比原来的参数个数少一个，因此重载的加法运算符函数只有1个本类对象作为形参，故选项D错误。运算符函数的函数名由运算符前加关键字operator构成，因此选项A和C不正确，选项B正确。"},{"title":"下列叙述中正确的是（）。","chooseList":[{"title":"对象标识可以不唯一","index":0,"selected":false},{"title":"对象是属性名和属性的封装体","index":1,"selected":false},{"title":"对象间的通信是靠方法调用","index":2,"selected":false},{"title":"对象具有封装性","index":3,"selected":false}],"mode":0,"answer":3,"parse":"本题的考查知识点是面向对象的特征。对象的基本特点包括：标识唯一性、分类性、多态性、封装性、模块独立性好。所以本题答案为D。"},{"title":"下面不属于软件需求规格说明书内容的是（）。","chooseList":[{"title":"软件的可验证性","index":0,"selected":false},{"title":"软件的功能需求","index":1,"selected":false},{"title":"软件的性能需求","index":2,"selected":false},{"title":"软件的外部接口","index":3,"selected":false}],"mode":0,"answer":0,"parse":"软件需求规格说明应重点描述软件的目标，软件的功能需求、性能需求、外部接口、属性及约束条件等，故选A。"},{"title":"关于面向对象的程序设计方法，下列说法正确的是（）。","chooseList":[{"title":"“封装性”指的是将不同类型的相关数据组合在一起，作为一个整体进行处理","index":0,"selected":false},{"title":"“多态性”指的是对象的状态会根据运行时要求自动变化","index":1,"selected":false},{"title":"基类的私有成员在派生类的对象中不可访问，也不占内存空间","index":2,"selected":false},{"title":"在面向对象的程序设计中，结构化程序设计方法仍有着重要作用","index":3,"selected":false}],"mode":0,"answer":3,"parse":"封装性是指将数据和算法捆绑成一个整体，这个整体就是对象，描述对象的数据被封装在其内部；多态性是指当多种事物继承自一种事物时，同一种操作在它们之间表现出不同的行为；基类的私有成员对派生类来说是不可访问的，因此在派生类中直接引用基类的私有变量成员是不允许的，可以通过基类的公用成员函数来引用基类的私有变量成员；C++是一种优秀的高级程序设计语言，它是以C语言为基础而逐渐发展起来的。C++语言既保留了传统的结构化程序设计方法，又对流行的面向对象程序设计方法提供了完整的支持。"},{"title":"已知：int m\u003d10;在下列定义引用的语句中，正确的是（）。","chooseList":[{"title":"int \u0026x \u003d m;","index":0,"selected":false},{"title":"int y \u003d \u0026m;","index":1,"selected":false},{"title":"int \u0026z;","index":2,"selected":false},{"title":"int \u0026t \u003d \u0026m;","index":3,"selected":false}],"mode":0,"answer":0,"parse":"本题主要考查了对引用及地址（\u0026）的理解，引用实际上就是别名，它与被引用变量拥有同一个地址空间，对于选项A而言，其操作实际上就是为m赋于一个别名x，因此选项A是对的。对于选项B，\u0026m表示m的地址，而y是一个整型变量，在C++中不能从地址值隐式转换为整型值，故选项B是错的。对于选项C，引用必须要用被引用的对象，即引用必须要初始化；选项D中t是一个整型引用，而其被引用的对象却是m的地址，存在着与选项B类似的错误，因此选项D也是错的。"},{"title":"关于友元，下列说法错误的是（）。","chooseList":[{"title":"友元关系不能被继承","index":0,"selected":false},{"title":"如果类A是类B的友元，那么类B也是类A的友元","index":1,"selected":false},{"title":"如果类A是类B的友元，那么类A的所有成员函数都是类B的友元","index":2,"selected":false},{"title":"如果函数fun()被说明为类A的友元，那么在fun()中可以访问类A的私有成员","index":3,"selected":false}],"mode":0,"answer":1,"parse":"本题主要考查了友元的概念，在C++中，有些对象或函数需要访问另一些对象的内部成员，这样我们可以用friend关键字来为对应的类指定友元函数或友元类，这种关系不是相互的。如果声明一个类A为另一个类B的友元类，则类A中的所有成元函数均可访问类B中的私有成员。友元关系不会被继承。"},{"title":"一个类可以同时继承多个类，称为多继承。下列关于多继承和虚基类的表述中，错误的是（）。","chooseList":[{"title":"每个派生类的构造函数都要为虚基类构造函数提供实参","index":0,"selected":false},{"title":"多继承时有可能出现对基类成员访问的二义性问题","index":1,"selected":false},{"title":"使用虚基类可以解决二义性问题并实现运行时的多态性","index":2,"selected":false},{"title":"建立最远派生类对象时，虚基类的构造函数会首先被调用","index":3,"selected":false}],"mode":0,"answer":2,"parse":"虚基类的构造函数将在其派生类创建实例时被执行，在执行时，派生类必须为虚基类的构造函数提供实参。在多重继承中，如果通过两条以上的路径对同一基类实行继承，这样，在派生类中将有多个基类的副本，从而产生二义性。在采用虚基类时，其成员将仅存唯一的副本，这样就可以解决二义性问题，但不能够实现运行时多态，可通过抽象类或虚拟函数来实现，虚基类的构造函数将会首先被执行。"},{"title":"有以下类定义：[image]下列语句中会发生编译错误的是（）。","chooseList":[{"title":"Point pt;pt.Print();","index":0,"selected":false},{"title":"const Point pt;pt.Print()","index":1,"selected":false},{"title":"Point pt;pt.Move(1,2);","index":2,"selected":false},{"title":"const Point pt;pt.Move(1,2);","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_31.png","parse":"本题主要考查了const关键字的使用。可以在类型或类名前加上const来声明一个在运行时不可改变的对象或变量。如果声明了一个常量对象，则其内部成员均不可改变，在编译时会检查其对应类的成员变量是否为左值，如果是，则会出现错误。对于B而言，由于在对象pt中的print方法中没有发现存在左值成员变量，故在编译时不会出错。"},{"title":"当派生类从一个基类保护继承时，基类中的一些成员在派生类中成为保护成员，这些成员在基类中原有的访问属性是（）。","chooseList":[{"title":"任何","index":0,"selected":false},{"title":"公有或保护","index":1,"selected":false},{"title":"保护或私有","index":2,"selected":false},{"title":"私有","index":3,"selected":false}],"mode":0,"answer":1,"parse":"派生类继承了基类的全部数据成员和除了构造、析构函数之外的全部成员函数，但是这些成员在派生类中的访问属性在派生的过程中是可以调整的，继承方式控制了基类中具有不同访问属性的成员在派生类中的访问属性。类的继承方式有公有继承（public）、保护继承（protected）和私有继承（private）三种。不同的继承方式，导致具有不同访问属性的基类成员在派生类中具有了新的访问属性。\n（1）基类中的私有成员在派生类中是隐藏的，只能在基类内部访问。因此选项A、C和D不正确。\n2）派生类从基类公有继承时，基类的公有成员和保护成员在派生类中仍然是公有成员和保护成员；派生类从基类私有继承时，基类的公有成员和保护成员在派生类中都改变为私有成员；派生类从基类保护继承时，基类的公有成员在派生类中改变为保护成员，基类的保护成员在派生类中仍为保护成员，因此选项B正确。"},{"title":"下列叙述中正确的是()。","chooseList":[{"title":"对象标识具有唯一性","index":0,"selected":false},{"title":"属性是对象的动态属性","index":1,"selected":false},{"title":"任何对象都必须有多态性","index":2,"selected":false},{"title":"对象是对象属性和方法的封装体","index":3,"selected":false}],"mode":0,"answer":0,"parse":"对象的基本特点包括：标识唯一性、分类性、多态性、封装性、模块独立性好。"},{"title":"在黑盒测试方法中，设计测试用例的根据是（）。","chooseList":[{"title":"数据结构","index":0,"selected":false},{"title":"程序调用规则","index":1,"selected":false},{"title":"软件要完成的功能","index":2,"selected":false},{"title":"模块间的逻辑关系","index":3,"selected":false}],"mode":0,"answer":2,"parse":"黑盒测试中，测试用例主要是依据需求进行编写。需求中描述软件需要完成的功能。软件的白盒测试和单元测试中可能使用编码过程中的逻辑关系，调用规则和数据结构。"},{"title":"执行下面的代码段：\nint n;\n cin \u003e\u003e n;\n switch(n) {\ncase 1:\ncase 2: cout \u003c\u003c \u00271\u0027;\ncase 3:\ncase 4: cout \u003c\u003c \u00272\u0027; break;\ndefault: cout \u003c\u003c \u00273\u0027;\n}\n若输入1，则屏幕显示（）。","chooseList":[{"title":"1","index":0,"selected":false},{"title":"2","index":1,"selected":false},{"title":"3","index":2,"selected":false},{"title":"12","index":3,"selected":false}],"mode":0,"answer":3,"parse":"switch语句又称为开关语句，它也是一种选择语句。switch语句的功能是根据给定表达式的不同取值来决定从多个语句序列中的哪一个开始执行。break语句又称为跳出语句。break语句只能用在switch语句和循环语句中。在switch语句中，break用来使执行流程跳出switch语句，而继续执行switch后面的语句。在循环语句中，break用来使执行流程无条件地跳出本层循环。"},{"title":"有以下程序：[image]程序执行后的输出结果是（）。","chooseList":[{"title":"1,2,1,2,","index":0,"selected":false},{"title":"1,2,2,3,","index":1,"selected":false},{"title":"2,0,3,0,","index":2,"selected":false},{"title":"1,0,2,0,","index":3,"selected":false}],"mode":0,"answer":3,"imageUrl":"https://aivenli.github.io/cputest/cpp/img/cpp_test3_19.png","parse":"本题主要考查了static型的变量，在C++中可以为函数或类指定static型的变量，如果将一个变量指定为static型，则该变量在内存中仅有一个副本，同时在函数或类执行完成后空间不会被释放，以前的值将会被保留。同时还考查了C++中变量作用域的问题，在C++中如果要将一个变量限定在指定的范围内，可以将该作用域用{}包含起来，同时可在函数的外部指定全局变量，该变量的作用范围是从当前位置开始到程序结束。对于“static int i\u003d1;”中的i，初始值为1，在调用std::cout\u003c\u003ci++\u003c\u003c\u0027,\u0027后，将输出“1,”，然后自加1，对于第二句std::cout\u003c\u003ci\u003c\u003c\u0027,\u0027，该i所代表的应该是全局变量“i”，故输出“0,”。在第二次执行fun()时，由于第一i为static型变量，其值是保留的，故输出“2,”，对于第二个i则输出“0,”。"},{"title":"在公有派生的情况下，派生类中定义的成员函数只能访问原基类的（）。","chooseList":[{"title":"公有成员和私有成员","index":0,"selected":false},{"title":"私有成员和保护成员","index":1,"selected":false},{"title":"公有成员和保护成员","index":2,"selected":false},{"title":"私有成员、保护成员和公有成员","index":3,"selected":false}],"mode":0,"answer":2,"parse":"在一个派生类中，其成员由两部分构成：一部分是从基类继承得到的，另一部分是自己定义的新成员，所有这些成员仍然分为公有、私有和保护三种访问属性。其中，从基类继承下来的全部成员构成派生类的基类部分，这部分的私有成员是派生类不能直接访问的，公有成员和保护成员则是派生类可以直接访问的，但是它们在派生类中的访问属性将随着派生类对基类的继承方式而改变。"},{"title":"下列是模板声明的开始部分，其中正确的是（）。","chooseList":[{"title":"template\u003cT\u003e","index":0,"selected":false},{"title":"template\u003cclass T1,T2\u003e","index":1,"selected":false},{"title":"template\u003cclass T1,class T2\u003e","index":2,"selected":false},{"title":"template\u003cclass T1;class T2\u003e","index":3,"selected":false}],"mode":0,"answer":2,"parse":"本题主要考查了模板的定义，在C++中可以在定义类时不指定具体的数据类型，而在编译时进行前期绑定，对于多参数的模板，在参数间用\",\"隔开，如果模板参数为一个类，在模板参数前面必须加上class关键字。"},{"title":"为了提高函数调用的实际运行速度，可以将较简单的函数定义为（）。","chooseList":[{"title":"内联函数","index":0,"selected":false},{"title":"重载函数","index":1,"selected":false},{"title":"递归函数","index":2,"selected":false},{"title":"函数模板","index":3,"selected":false}],"mode":0,"answer":0,"parse":"内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。这样就节省了参数传递、控制转移等开销。因此对于一些功能简单、规模较小又使用频繁的函数，可以设计为内联函数。故选A。"},{"title":"C++系统预定义了4个用于标准数据流的对象，下列选项中不属于此类对象的是（）。","chooseList":[{"title":"cout","index":0,"selected":false},{"title":"cin","index":1,"selected":false},{"title":"cerr","index":2,"selected":false},{"title":"cset","index":3,"selected":false}],"mode":0,"answer":3,"parse":"C++流有4个预定义的流对象，它们的名称及与之联系的I/O设备如下：cin标准输入、cout标准输出、cerr标准出错信息输出、clog带缓冲的标准出错信息输出。因此选项D不属于此类对象。"}]}